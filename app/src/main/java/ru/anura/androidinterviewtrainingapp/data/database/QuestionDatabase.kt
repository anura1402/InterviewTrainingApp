package ru.anura.androidinterviewtrainingapp.data.database

import android.app.Application
import android.util.Log
import androidx.room.Database
import androidx.room.Room
import androidx.room.RoomDatabase
import androidx.room.TypeConverters
import androidx.room.migration.Migration
import androidx.sqlite.db.SupportSQLiteDatabase

@Database(entities = [QuestionDBModel::class], version =3, exportSchema = false)
@TypeConverters(Converters::class)
abstract class QuestionDatabase : RoomDatabase() {
    abstract fun questionDao(): QuestionDao

    companion object {
        // Volatile annotation means any change to this field
        // are immediately visible to other threads.
        @Volatile
        private var INSTANCE: QuestionDatabase? = null
        private val LOCK = Any()
        private const val DB_NAME = "question_database.db"

        private val MIGRATION_1_2 = object : Migration(1, 2) {
            override fun migrate(db: SupportSQLiteDatabase) {
                db.execSQL("DELETE FROM questionTable")

                db.execSQL(
                    """
                    INSERT INTO questionTable (
                      question_text, question_image, question_options, question_answer, question_theme, isCorrectAnswer, isFavorite, question_explanation
                    ) VALUES
                   ('Какие ключевые особенности языка Java?', '', '["Объектно-Ориентированное Программирование", "Платформенная независимость", "Автоматическое управление памятью", "Низкоуровневое программирование"]', '["Объектно-Ориентированное Программирование", "Платформенная независимость", "Автоматическое управление памятью"]', 'JAVA', 1, 0, 'Java поддерживает ООП, платформенную независимость и автоматическое управление памятью через сборщик мусора.'),
                   ('Что такое корутины в Kotlin?', '', '["Механизм асинхронного программирования", "Тип данных", "Интерфейс", "Класс"]', '["Механизм асинхронного программирования"]', 'KOTLIN', 1, 0, 'Корутины в Kotlin позволяют писать асинхронный код более простым и понятным способом.'),
                    ('Что такое SQL JOIN?', '', '["Операция объединения данных из нескольких таблиц", "Команда для создания таблицы", "Функция для фильтрации данных", "Механизм для сортировки данных"]', '["Операция объединения данных из нескольких таблиц"]', 'SQL', 1, 0, 'JOIN используется для объединения данных из нескольких таблиц по определённым условиям.'),
                   ('Какой компонент Android отвечает за отображение пользовательского интерфейса?', '', '["Activity", "Service", "Broadcast Receiver", "Content Provider"]', '["Activity"]', 'ANDROID', 1, 0, 'Activity управляет пользовательским интерфейсом в Android приложениях.'),
                    ('Что такое база данных в контексте SQL?', '', '["Структурированный набор данных", "Функция для обработки данных", "Тип данных", "Механизм для потоковой передачи данных"]', '["Структурированный набор данных"]', 'BASE', 1, 0, 'База данных — это структурированный набор данных, который можно эффективно управлять и извлекать.'),
                   ('Что такое многопоточность в программировании?', '', '["Способ выполнения нескольких задач одновременно", "Метод оптимизации кода", "Инструмент для работы с базами данных", "Функция для управления памятью"]', '["Способ выполнения нескольких задач одновременно"]', 'THREADS', 1, 0, 'Многопоточность позволяет выполнять несколько потоков выполнения одновременно, что может улучшить производительность приложения.'),
                  ('Какая структура данных используется для хранения пар ключ-значение в Kotlin?', '', '["Map", "List", "Set", "Array"]', '["Map"]', 'KOTLIN', 1, 0, 'Map в Kotlin используется для хранения пар ключ-значение, позволяя эффективно искать значения по ключам.'),
                   ('Какой тип базы данных поддерживает SQL?', '', '["Реляционные базы данных", "Документные базы данных", "Графовые базы данных", "Ключ-значение базы данных"]', '["Реляционные базы данных"]', 'SQL', 1, 0, 'SQL используется для работы с реляционными базами данных, которые хранят данные в таблицах с фиксированной схемой.'),
                   ('Какой класс в Android используется для хранения данных в фоновом режиме?', '', '["Service", "Activity", "Broadcast Receiver", "Content Provider"]', '["Service"]', 'ANDROID', 1, 0, 'Service позволяет выполнять долгосрочные операции в фоновом режиме, не привязываясь к пользовательскому интерфейсу.'),
                   ('Что такое аннотации в Java?', '', '["Метаданные, которые можно добавлять к коду", "Специальные переменные", "Типы данных", "Методы для обработки ошибок"]', '["Метаданные, которые можно добавлять к коду"]', 'JAVA', 1, 0, 'Аннотации в Java используются для добавления метаданных к коду, которые могут использоваться на этапе компиляции или выполнения.'),
                ('Что такое объектно-ориентированное программирование?', '', '["Парадигма программирования, основанная на использовании объектов", "Метод структурного программирования", "Функциональный стиль программирования", "Подход к оптимизации кода"]', '["Парадигма программирования, основанная на использовании объектов"]', 'BASE', 1, 0, 'ООП — это парадигма программирования, основанная на концепциях объектов и классов, которые инкапсулируют состояние и поведение.')
        """
                )
                db.execSQL(
                    "UPDATE questionTable\n" +
                            "SET isCorrectAnswer = 0;"
                )
            }
        }
        private val MIGRATION_2_3 = object : Migration(2, 3) {
            override fun migrate(db: SupportSQLiteDatabase) {
                db.execSQL(
                    """
                    INSERT INTO questionTable (
                      question_text, question_image, question_options, question_answer, question_theme, isCorrectAnswer, isFavorite, question_explanation
                    ) VALUES
                   ('Для чего нужен data class?', '', '["Для упрощения создания классов, предназначенных для хранения данных", "Для управления потоками", "Для обработки исключений", "Для работы с базами данных"]', '["Для упрощения создания классов, предназначенных для хранения данных"]', 'KOTLIN', 0, 0, 'Data class в Kotlin используется для упрощения создания классов, которые предназначены для хранения данных. Такие классы автоматически получают методы, как equals(), hashCode(), toString(), и copy().'),
                    ('Какие функции генерирует data class?', '', '["equals()/hashCode()", "toString()", "componentN()", "copy()", "run()", "get()"]', '["equals()/hashCode()", "toString()", "componentN()", "copy()"]', 'KOTLIN', 0, 0, 'Data class в Kotlin автоматически генерирует функции equals()/hashCode(), toString(), componentN(), и copy() для работы с данными, хранящимися в объекте.'),
                    ('Какие знаешь методы жизненного цикла Activity?', '', '["onCreate()", "onRestart()", "onResume()", "onPause()", "onStop()", "onDestroy()", "onError()", "onComplete()"]', '["onCreate()", "onRestart()", "onResume()", "onPause()", "onStop()", "onDestroy()"]', 'ANDROID', 0, 0, 'Методы жизненного цикла Activity в Android включают onCreate(), onRestart(), onResume(), onPause(), onStop(), и onDestroy(). Эти методы управляют состояниями активности в приложении.'),
                    ('Что происходит при методе onCreate?', '', '["Создание пользовательского интерфейса", "Инициализация данных класса", "Выполнение действий, которые должны произойти один раз за время жизни Activity", "Запуск сервиса", "Отправка данных на сервер"]', '["Создание пользовательского интерфейса", "Инициализация данных класса", "Выполнение действий, которые должны произойти один раз за время жизни Activity"]', 'ANDROID', 0, 0, 'Метод onCreate() в Android вызывается при создании Activity. В этом методе происходит создание пользовательского интерфейса, инициализация данных класса и выполнение действий, которые должны произойти один раз за время жизни Activity.'),
                    ('Когда вызывается onStart?', '', '["Когда Activity становится видимым для пользователя", "Когда Activity уничтожается", "Когда пользователь нажимает кнопку назад", "Когда происходит ошибка в приложении"]', '["Когда Activity становится видимым для пользователя"]', 'ANDROID', 0, 0, 'Метод onStart() вызывается, когда Activity становится видимым для пользователя, но еще не взаимодействует с ним. Этот этап жизненного цикла подготавливает активность к отображению на экране.'),
                    ('Когда вызывается onResume?', '', '["Непосредственно перед тем, как Activity начинает взаимодействовать с пользователем", "Когда Activity уничтожается", "Когда приложение переходит в фоновый режим", "Когда пользователь нажимает кнопку назад"]', '["Непосредственно перед тем, как Activity начинает взаимодействовать с пользователем"]', 'ANDROID', 0, 0, 'Метод onResume() вызывается непосредственно перед тем, как Activity начинает взаимодействовать с пользователем. В этот момент активность находится на переднем плане и готова обрабатывать пользовательские действия.'),
                    ('Когда вызывается onPause?', '', '["Когда система собирается продолжить или возобновить другую Activity", "Когда приложение закрывается", "Когда пользователь завершает работу с приложением", "Когда устройство перезагружается"]', '["Когда система собирается продолжить или возобновить другую Activity"]', 'ANDROID', 0, 0, 'Метод onPause() вызывается, когда система собирается продолжить или возобновить другую Activity. В этот момент активность перестает быть на переднем плане, но еще не уничтожена.'),
                    ('Когда вызывается onStop?', '', '["Когда Activity больше не видно пользователю, потому что другое Activity было возобновлено и покрыло его", "Когда приложение переходит в фоновый режим", "Когда пользователь завершает работу с Activity", "Когда устройство выключается"]', '["Когда Activity больше не видно пользователю, потому что другое Activity было возобновлено и покрыло его"]', 'ANDROID', 0, 0, 'Метод onStop() вызывается, когда Activity больше не видно пользователю, так как другое Activity было возобновлено и покрыло его. На этом этапе активность не уничтожается, но может быть завершена в зависимости от действий пользователя.'),
                    ('Когда вызывается onRestart?', '', '["После того, как Activity было остановлено, но снова начинает запускаться для взаимодействия с пользователем", "После завершения работы приложения", "Когда Activity уничтожается", "Когда пользователь закрывает приложение"]', '["После того, как Activity было остановлено, но снова начинает запускаться для взаимодействия с пользователем"]', 'ANDROID', 0, 0, 'Метод onRestart() вызывается после того, как Activity была остановлена, но снова начинает запускаться для взаимодействия с пользователем. Этот метод вызывается перед тем, как активность снова станет видимой.'),
                    ('Когда вызывается onDestroy?', '', '["Перед уничтожением Activity", "Когда Activity становится видимой для пользователя", "После завершения работы приложения", "Когда пользователь нажимает кнопку назад"]', '["Перед уничтожением Activity"]', 'ANDROID', 0, 0, 'Метод onDestroy() вызывается перед тем, как Activity будет окончательно уничтожена. Этот метод используется для выполнения окончательной очистки ресурсов и завершения любых процессов, связанных с активностью.'),
                    ('Когда вызывается onCreate?', '', '["При первом создании Activity", "Когда Activity становится видимой для пользователя", "При переходе приложения в фоновый режим", "Когда пользователь завершает работу с Activity"]', '["При первом создании Activity"]', 'ANDROID', 0, 0, 'Метод onCreate() вызывается при первом создании Activity. В этом методе происходит инициализация активности, создание пользовательского интерфейса и выполнение действий, которые должны произойти только один раз за время жизни активности.'),
                    ('За какими методами может следовать onStart?', '', '["onCreate()", "onRestart()", "onResume()", "onPause()"]', '["onCreate()", "onRestart()"]', 'ANDROID', 0, 0, 'Метод onStart() может следовать за методами onCreate() и onRestart(). onCreate() вызывается при первом создании активности, а onRestart() — когда активность, которая была остановлена, снова начинает запускаться.'),
                    ('Зачем нужен метод onPause?', '', '["Для остановки динамических элементов, которые могли быть запущены во время onResume()", "Для освобождения ресурсов, которые могут быть нужны другим приложениям", "Для сохранения данных в базе данных", "Для выполнения фоновых задач"]', '["Для остановки динамических элементов, которые могли быть запущены во время onResume()", "Для освобождения ресурсов, которые могут быть нужны другим приложениям"]', 'ANDROID', 0, 0, 'Метод onPause() нужен для остановки динамических элементов, которые могли быть запущены во время onResume(), а также для освобождения ресурсов, которые могут быть нужны другим приложениям. Этот метод помогает оптимизировать использование ресурсов и подготовить активность к потенциальному переходу в фоновый режим.'),
                    ('Зачем нужен метод onStop?', '', '["Для выполнения более тяжеловесной очистки ресурсов", "Для сохранения пользовательских данных", "Для запуска фоновых задач", "Для обновления пользовательского интерфейса"]', '["Для выполнения более тяжеловесной очистки ресурсов"]', 'ANDROID', 0, 0, 'Метод onStop() используется для выполнения более тяжеловесной очистки ресурсов, которые могут не понадобиться, пока активность не станет видимой снова. В этом методе можно освободить ресурсы, которые не используются, когда активность не видна пользователю.'),
                    ('Что делает onRestart?', '', '["Восстанавливает состояние Activity в том виде, в каком оно было перед тем, как было остановлено", "Запускает Activity заново с чистого состояния", "Инициализирует данные перед запуском Activity", "Закрывает активность"]', '["Восстанавливает состояние Activity в том виде, в каком оно было перед тем, как было остановлено"]', 'ANDROID', 0, 0, 'Метод onRestart() восстанавливает состояние Activity в том виде, в каком оно было перед тем, как активность была остановлена. Этот метод вызывается перед тем, как активность снова станет видимой для пользователя.'),
                    ('Зачем нужен метод onDestroy?', '', '["Для освобождения всех ресурсов, которые не были освобождены автоматически системой", "Для создания нового состояния активности", "Для инициализации данных перед запуском Activity", "Для выполнения фоновых задач"]', '["Для освобождения всех ресурсов, которые не были освобождены автоматически системой"]', 'ANDROID', 0, 0, 'Метод onDestroy() нужен для освобождения всех ресурсов, которые не были освобождены автоматически системой. Этот метод вызывается перед окончательным уничтожением активности, что позволяет выполнить завершающие операции очистки и освободить ресурсы, связанные с активностью.'),
                    ('При каких методах Activity видна на экране?', '', '["onStart()", "onResume()", "onPause()", "onStop()"]', '["onStart()", "onResume()"]', 'ANDROID', 0, 0, 'Activity видна на экране при вызове методов onStart() и onResume(). В onStart() активность становится видимой для пользователя, а в onResume() активность начинает взаимодействовать с пользователем. В onPause() активность уже не видна, так как она находится в состоянии частичного скрытия.'),
                    ('Какие основные компоненты Android приложения?', '', '["Activity", "Service", "Broadcast Receiver", "Content Provider", "Fragment", "View"]', '["Activity", "Service", "Broadcast Receiver", "Content Provider"]', 'ANDROID', 0, 0, 'Основные компоненты Android приложения включают Activity, Service, Broadcast Receiver и Content Provider. Эти компоненты взаимодействуют друг с другом, обеспечивая функциональность и взаимодействие приложения.'),
                    ('Что такое Activity?', '', '["Экран с пользовательским интерфейсом", "Сервис для выполнения фоновых задач", "Компонент для обработки системных сообщений", "Хранилище данных"]', '["Экран с пользовательским интерфейсом"]', 'ANDROID', 0, 0, 'Activity — это компонент Android приложения, представляющий собой экран с пользовательским интерфейсом. Он отвечает за отображение интерфейса и взаимодействие с пользователем.'),
                    ('Для чего нужны Activity?', '', '["Для выполнения одной конкретной задачи", "Для управления фоновыми задачами", "Для обработки системных сообщений", "Для хранения и управления данными"]', '["Для выполнения одной конкретной задачи"]', 'ANDROID', 0, 0, 'Activity используются для выполнения одной конкретной задачи, связанной с пользовательским интерфейсом. Каждая Activity представляет собой отдельный экран или окно, которое выполняет определенную функцию в приложении.'),
                    ('Для чего нужны Services?', '', '["Для выполнения длительных или фоновых операций без предоставления пользовательского интерфейса", "Для отображения информации пользователю", "Для обработки пользовательских событий", "Для хранения данных в приложении"]', '["Для выполнения длительных или фоновых операций без предоставления пользовательского интерфейса"]', 'ANDROID', 0, 0, 'Services в Android используются для выполнения длительных или фоновых операций без предоставления пользовательского интерфейса. Они позволяют продолжать работу приложения даже когда пользователь не взаимодействует с ним напрямую.'),
                    ('Для чего нужны Broadcast Receivers?', '', '["Для прослушивания и реагирования на широковещательные сообщения от других приложений или системы", "Для хранения данных в приложении", "Для отображения пользовательского интерфейса", "Для выполнения фоновых задач"]', '["Для прослушивания и реагирования на широковещательные сообщения от других приложений или системы"]', 'ANDROID', 0, 0, 'Broadcast Receivers используются для прослушивания и реагирования на широковещательные сообщения от других приложений или системы. Они позволяют приложению реагировать на различные события, такие как подключение к сети, низкий уровень заряда батареи и другие системные или пользовательские события.'),
                    ('Для чего нужны Content Providers?', '', '["Позволяют приложениям хранить и делиться данными", "Для обработки пользовательских запросов", "Для управления жизненным циклом Activity", "Для выполнения фоновых задач"]', '["Позволяют приложениям хранить и делиться данными"]', 'ANDROID', 0, 0, 'Content Providers нужны для того, чтобы приложения могли хранить и делиться данными с другими приложениями. Они обеспечивают стандартный интерфейс для доступа к данным, таким как контакты, медиафайлы и другие ресурсы, хранящиеся в приложении.'),
                    ('Какие задачи может выполнять Activity?', '', '["Выбор фотографии из галереи", "Отправка сообщения", "Воспроизведение музыки в фоновом режиме", "Хранение данных в базе данных"]', '["Выбор фотографии из галереи", "Отправка сообщения"]', 'ANDROID', 0, 0, 'Activity может выполнять задачи, связанные с пользовательским интерфейсом, такие как выбор фотографии из галереи и отправка сообщения. Эти действия обычно включают взаимодействие пользователя с приложением на экране.'),
                    ('Какие задачи может выполнять Service?', '', '["Воспроизводить музыку в фоне", "Синхронизировать данные в фоновом режиме", "Отображать пользовательский интерфейс", "Выбирать фотографию из галереи"]', '["Воспроизводить музыку в фоне", "Синхронизировать данные в фоновом режиме"]', 'ANDROID', 0, 0, 'Service может выполнять задачи, которые не требуют взаимодействия с пользователем, такие как воспроизведение музыки в фоновом режиме и синхронизация данных. Эти операции могут продолжаться, даже если пользователь не взаимодействует с приложением напрямую.'),
                    ('Какие задачи может выполнять Broadcast Receiver?', '', '["Запуск определенных действий или уведомлений в ответ на сообщения о низком заряде батареи", "Реагировать на загрузку новой фотографии", "Сохранять данные в базе данных", "Запускать фоновые задачи, такие как обновление контента"]', '["Запуск определенных действий или уведомлений в ответ на сообщения о низком заряде батареи", "Реагировать на загрузку новой фотографии"]', 'ANDROID', 0, 0, 'Broadcast Receiver может выполнять задачи, такие как запуск определенных действий или уведомлений в ответ на сообщения о низком заряде батареи или загрузке новой фотографии. Он реагирует на широковещательные сообщения, поступающие от системы или других приложений.'),
                    ('Какие задачи может выполнять Content Provider?', '', '["Доступ к контактам", "Доступ к медиафайлам", "Управление потоками", "Обработка системных уведомлений"]', '["Доступ к контактам", "Доступ к медиафайлам"]', 'ANDROID', 0, 0, 'Content Provider может выполнять задачи, такие как доступ к контактам и медиафайлам. Он обеспечивает приложениям доступ к данным, хранящимся в других приложениях, а также позволяет управлять этими данными.'),
                    ('Какие преимущества Kotlin в Android разработке?', '', '["Более краткий и выразительный синтаксис", "Null безопасность", "Extension functions", "Поддержка функционального программирования", "Полная совместимость с Java", "Корутины для асинхронного программирования", "Официальная поддержка Google", "Упрощенное управление потоками", "Поддержка мультипоточности"]', '["Более краткий и выразительный синтаксис", "Null безопасность", "Extension functions", "Поддержка функционального программирования", "Полная совместимость с Java", "Корутины для асинхронного программирования", "Официальная поддержка Google"]', 'KOTLIN', 0, 0, 'Kotlin предлагает множество преимуществ для Android разработки, таких как более краткий и выразительный синтаксис, Null безопасность, Extension functions, поддержка функционального программирования, полная совместимость с Java, корутины для асинхронного программирования и официальная поддержка Google. Эти особенности делают Kotlin предпочтительным языком для создания Android приложений.'),
                    ('Что такое Fragment?', '', '["Модульная часть пользовательского интерфейса в Activity", "Компонент для выполнения фоновых задач", "Хранилище данных в приложении", "Механизм управления потоками в Android"]', '["Модульная часть пользовательского интерфейса в Activity"]', 'ANDROID', 0, 0, 'Fragment — это модульная часть пользовательского интерфейса в Activity. Он позволяет разделить интерфейс на независимые и переиспользуемые части, которые можно комбинировать в разных конфигурациях в пределах одной активности.'),
                    ('Какие преимущества у фрагментов?', '', '["Модульность", "Переиспользование компонентов", "Адаптивный интерфейс", "Управление жизненным циклом", "Упрощение обработки взаимодействий", "Поддержка динамических и гибких интерфейсов", "Повышение производительности", "Упрощенная отладка приложений"]', '["Модульность", "Переиспользование компонентов", "Адаптивный интерфейс", "Управление жизненным циклом", "Упрощение обработки взаимодействий", "Поддержка динамических и гибких интерфейсов"]', 'ANDROID', 0, 0, 'Фрагменты предоставляют множество преимуществ, таких как модульность, переиспользование компонентов, адаптивный интерфейс, управление жизненным циклом, упрощение обработки взаимодействий и поддержка динамических и гибких интерфейсов. Эти особенности позволяют создавать более гибкие и управляемые пользовательские интерфейсы в Android приложениях.'),
                    ('В чем заключается преимущество "Модульность" у фрагментов?', '', '["Фрагменты позволяют разбить сложный пользовательский интерфейс на управляемые части", "Каждый фрагмент может быть разработан и оттестирован независимо от других", "Каждый фрагмент может комбинироваться в различных комбинациях для создания адаптивного интерфейса приложения", "Фрагменты упрощают управление потоками данных"]', '["Фрагменты позволяют разбить сложный пользовательский интерфейс на управляемые части", "Каждый фрагмент может быть разработан и оттестирован независимо от других", "Каждый фрагмент может комбинироваться в различных комбинациях для создания адаптивного интерфейса приложения"]', 'ANDROID', 0, 0, 'Преимущество "Модульность" у фрагментов заключается в том, что они позволяют разбить сложный пользовательский интерфейс на управляемые части, которые можно разрабатывать и тестировать независимо друг от друга. Каждый фрагмент также может комбинироваться в различных комбинациях, что способствует созданию адаптивного интерфейса приложения.'),
                    ('В чем заключается преимущество "Переиспользование компонентов" у фрагментов?', '', '["Фрагменты можно использовать в нескольких активностях, что способствует повторному использованию кода", "Фрагменты можно интегрировать с различными сервисами Android", "Фрагменты упрощают управление жизненным циклом активности", "Фрагменты позволяют создать универсальный интерфейс для всех устройств"]', '["Фрагменты можно использовать в нескольких активностях, что способствует повторному использованию кода"]', 'ANDROID', 0, 0, 'Преимущество "Переиспользование компонентов" у фрагментов заключается в том, что они могут использоваться в нескольких активностях, что способствует повторному использованию кода. Это позволяет эффективно управлять интерфейсом и логикой приложения, не дублируя код.'),
                    ('В чем заключается преимущество "Адаптивный интерфейс" у фрагментов?', '', '["Корректная работа на устройствах с различными размерами экранов и ориентациями", "Отображение нескольких фрагментов на планшетах одновременно, в то время как на смартфонах — поочередно", "Автоматическое изменение цветовой схемы в зависимости от времени суток", "Оптимизация приложений для различных версий Android"]', '["Корректная работа на устройствах с различными размерами экранов и ориентациями", "Отображение нескольких фрагментов на планшетах одновременно, в то время как на смартфонах — поочередно"]', 'ANDROID', 0, 0, 'Преимущество "Адаптивный интерфейс" у фрагментов заключается в обеспечении корректной работы приложения на устройствах с различными размерами экранов и ориентациями. Это позволяет отображать несколько фрагментов одновременно на планшетах, в то время как на смартфонах они могут отображаться поочередно, что делает интерфейс более гибким и адаптивным.'),
                    ('В чем заключается преимущество "Управление жизненным циклом" у фрагментов?', '', '["Управление поведением фрагментов в зависимости от состояния активности", "Автоматическая синхронизация данных между фрагментами", "Оптимизация производительности фрагментов", "Управление сетевыми запросами фрагментов"]', '["Управление поведением фрагментов в зависимости от состояния активности"]', 'ANDROID', 0, 0, 'Преимущество "Управление жизненным циклом" у фрагментов заключается в возможности управления поведением фрагментов в зависимости от состояния активности. Это позволяет эффективно управлять ресурсами и состоянием пользовательского интерфейса, обеспечивая корректное отображение и функционирование фрагментов при изменении состояния активности.'),
                    ('В чем заключается преимущество "Упрощение обработки взаимодействий" у фрагментов?', '', '["Фрагменты могут взаимодействовать друг с другом через Activity", "Фрагменты автоматически обрабатывают все пользовательские взаимодействия", "Фрагменты упрощают настройку элементов пользовательского интерфейса", "Фрагменты обрабатывают взаимодействия с внешними сервисами"]', '["Фрагменты могут взаимодействовать друг с другом через Activity"]', 'ANDROID', 0, 0, 'Преимущество "Упрощение обработки взаимодействий" у фрагментов заключается в том, что фрагменты могут взаимодействовать друг с другом через Activity. Это позволяет координировать действия и обмениваться данными между фрагментами, упрощая управление взаимодействиями внутри пользовательского интерфейса.'),
                    ('В чем заключается преимущество "Поддержка динамических и гибких интерфейсов" у фрагментов?', '', '["Фрагменты можно добавлять, удалять, заменять и выполнять с ними другие действия во время выполнения активности", "Фрагменты автоматически адаптируются под различные размеры экранов", "Фрагменты оптимизируют работу интерфейса для разных устройств", "Фрагменты управляют изменением ориентации экрана"]', '["Фрагменты можно добавлять, удалять, заменять и выполнять с ними другие действия во время выполнения активности"]', 'ANDROID', 0, 0, 'Преимущество "Поддержка динамических и гибких интерфейсов" у фрагментов заключается в том, что их можно добавлять, удалять, заменять и выполнять с ними другие действия во время выполнения активности. Это обеспечивает гибкость в изменении пользовательского интерфейса без необходимости пересоздавать активность, что позволяет адаптировать интерфейс приложения под различные сценарии использования.'),
                    ('Для чего нужны сервисы?', '', '["Выполнение фоновых задач", "Воспроизведение музыки или выполнение других длительных операций", "Обработка сетевых запросов", "Работа с внешними устройствами (например, Bluetooth)", "Выполнение периодических задач", "Предоставление функциональности другим приложениям"]', '["Выполнение фоновых задач", "Воспроизведение музыки или выполнение других длительных операций", "Обработка сетевых запросов", "Работа с внешними устройствами (например, Bluetooth)", "Выполнение периодических задач", "Предоставление функциональности другим приложениям"]', 'ANDROID', 0, 0, 'Сервисы нужны для выполнения фоновых задач, таких как воспроизведение музыки, обработка сетевых запросов, работа с внешними устройствами (например, Bluetooth), выполнение периодических задач и предоставление функциональности другим приложениям. Они позволяют выполнять длительные операции и обеспечивать поддержку приложений даже когда пользователь не взаимодействует с ними напрямую.'),
                    ('Что такое MVVM и MVP?', '', '["Паттерны, используемые для разделения логики приложения на управляемые компоненты с целью упрощения разработки и обеспечения тестируемости", "Методы для оптимизации работы с базами данных", "Техники для улучшения пользовательского интерфейса", "Стратегии для работы с многопоточностью"]', '["Паттерны, используемые для разделения логики приложения на управляемые компоненты с целью упрощения разработки и обеспечения тестируемости"]', 'BASE', 0, 0, 'MVVM (Model-View-ViewModel) и MVP (Model-View-Presenter) — это паттерны проектирования, используемые для разделения логики приложения на управляемые компоненты. Они помогают упрощать разработку и обеспечивать тестируемость, разделяя пользовательский интерфейс (View), бизнес-логику (Model) и промежуточный слой для управления взаимодействием (ViewModel или Presenter).'),
                    ('Расшифруйте MVP:', '', '["Model", "View", "Presenter", "Model-View-Controller"]', '["Model", "View", "Presenter"]', 'BASE', 0, 0, 'MVP расшифровывается как Model-View-Presenter. В этом паттерне `Model` представляет бизнес-логику и данные, `View` отвечает за отображение данных и взаимодействие с пользователем, а `Presenter` управляет взаимодействием между `Model` и `View`, обеспечивая обновление данных и обработку пользовательских событий.'),
                    ('Расшифруйте MVVM:', '', '["Model", "View", "ViewModel", "Model-View-Presenter"]', '["Model", "View", "ViewModel"]', 'BASE', 0, 0, 'MVVM расшифровывается как Model-View-ViewModel. В этом паттерне `Model` представляет бизнес-логику и данные, `View` отвечает за отображение данных и взаимодействие с пользователем, а `ViewModel` управляет состоянием `View` и предоставляет данные из `Model`, а также обрабатывает команды и события, обеспечивая связь между `Model` и `View`.'),
                    ('Какой слой представляет собой слой данных и бизнес-логики приложения?', '', '["Model", "View", "ViewModel", "Presenter"]', '["Model"]', 'BASE', 0, 0, 'Слой, который представляет собой слой данных и бизнес-логики приложения, это `Model`. Он отвечает за управление данными и бизнес-логику, а также взаимодействует с источниками данных, такими как базы данных или веб-сервисы.'),
                    ('Какой слой отвечает за отображение данных (UI)?', '', '["Model", "View", "ViewModel", "Presenter"]', '["View"]', 'BASE', 0, 0, 'Слой, который отвечает за отображение данных и пользовательский интерфейс (UI), это `View`. Он занимается отображением данных пользователю и обработкой его взаимодействий с интерфейсом.'),
                    ('За что отвечает Presenter?', '', '["Является посредником между Model и View", "Содержит логику представления", "Реагирует на действия пользователя, обрабатывая их через Model и обновляя View", "Управляет состоянием данных и их представлением"]', '["Является посредником между Model и View", "Содержит логику представления", "Реагирует на действия пользователя, обрабатывая их через Model и обновляя View"]', 'BASE', 0, 0, 'Presenter отвечает за посредничество между `Model` и `View`. Он содержит логику представления, реагирует на действия пользователя, обрабатывая их через `Model` и обновляя `View`. Таким образом, Presenter управляет взаимодействием между данными и пользовательским интерфейсом.'),
                    ('За что отвечает ViewModel?', '', '["Служит абстракцией View и содержит логику представления", "ViewModel взаимодействует с Model, обрабатывает данные и подготавливает их для отображения", "ViewModel может автоматически обновлять View без необходимости напрямую взаимодействовать с ним", "ViewModel управляет состоянием приложения и его навигацией"]', '["Служит абстракцией View и содержит логику представления", "ViewModel взаимодействует с Model, обрабатывает данные и подготавливает их для отображения", "ViewModel может автоматически обновлять View без необходимости напрямую взаимодействовать с ним"]', 'BASE', 0, 0, 'ViewModel служит абстракцией `View` и содержит логику представления. Он взаимодействует с `Model`, обрабатывает данные и подготавливает их для отображения. Также ViewModel может автоматически обновлять `View` без необходимости напрямую взаимодействовать с ним, что упрощает управление состоянием и взаимодействием приложения.'),
                    ('В чем отличие MVVM от MVP?', '', '["В MVVM обновления View происходят автоматически через механизмы привязки данных", "В MVP Presenter активно управляет View, что требует более явного обновления пользовательского интерфейса в ответ на изменения данных или состояния приложения", "MVVM использует активные методы взаимодействия с данными, в то время как MVP ориентирован на инертные методы", "MVVM не требует использования ViewModel, а MVP не использует Presenter"]', '["В MVVM обновления View происходят автоматически через механизмы привязки данных", "В MVP Presenter активно управляет View, что требует более явного обновления пользовательского интерфейса в ответ на изменения данных или состояния приложения"]', 'BASE', 0, 0, 'Основное отличие между MVVM и MVP заключается в способе обновления `View`. В MVVM обновления `View` происходят автоматически через механизмы привязки данных, что позволяет более легко синхронизировать данные и пользовательский интерфейс. В MVP же `Presenter` активно управляет `View`, что требует более явного обновления пользовательского интерфейса в ответ на изменения данных или состояния приложения.'),
                    ('Для чего нужен класс Nothing?', '', '["Он представляет тип, который не имеет значений и используется для обозначения операций, которые никогда не завершаются нормально", "Он представляет тип данных, который может содержать любые значения", "Он используется для хранения значений по умолчанию", "Он предназначен для работы с пустыми коллекциями"]', '["Он представляет тип, который не имеет значений и используется для обозначения операций, которые никогда не завершаются нормально"]', 'KOTLIN', 0, 0, 'Класс `Nothing` в Kotlin представляет тип, который не имеет значений и используется для обозначения операций, которые никогда не завершаются нормально. Это может включать бесконечные циклы, вызовы функций, которые бросают исключения, или любые другие ситуации, где выполнение кода не завершится успешно.'),
                    ('Какие преимущества у класса Nothing?', '', '["Обозначение "недостижимого" кода", "Помощь в статическом анализе кода", "Улучшение читабельности и понимания кода", "Оптимизация производительности программы", "Обработка исключений и ошибок"]', '["Обозначение "недостижимого" кода", "Помощь в статическом анализе кода", "Улучшение читабельности и понимания кода"]', 'KOTLIN', 0, 0, 'Преимущества класса `Nothing` включают обозначение "недостижимого" кода, помощь в статическом анализе кода и улучшение читабельности и понимания кода. Он помогает явно указать, что определенные участки кода не могут быть достигнуты или завершены нормально, что улучшает надежность и поддержку кода.'),
                    ('Какие аспекты у класса Nothing?', '', '["Указание возвращаемого типа Nothing демонстрирует, что участок кода всегда завершается с ошибкой", "Компилятор и инструменты статического анализа могут выводить, что последующий код недостижим", "Указания, что функция не возвращает ничего и не должна завершиться, делает код понятным и читаемым", "Использование Nothing помогает оптимизировать выполнение программ"]', '["Указание возвращаемого типа Nothing демонстрирует, что участок кода всегда завершается с ошибкой", "Компилятор и инструменты статического анализа могут выводить, что последующий код недостижим", "Указания, что функция не возвращает ничего и не должна завершиться, делает код понятным и читаемым"]', 'KOTLIN', 0, 0, 'Аспекты класса `Nothing` включают указание возвращаемого типа `Nothing`, что демонстрирует, что участок кода всегда завершается с ошибкой. Компилятор и инструменты статического анализа могут выявлять недостижимость последующего кода. Также указания, что функция не возвращает ничего и не должна завершиться, делают код более понятным и читаемым.'),
                    ('Что такое корутины?', '', '["Мощный инструмент для асинхронного программирования, позволяющий писать асинхронный код почти так же просто и понятно, как и синхронный", "Способ обработки многопоточности в Java", "Технология для улучшения производительности баз данных", "Метод для работы с графическим интерфейсом"]', '["Мощный инструмент для асинхронного программирования, позволяющий писать асинхронный код почти так же просто и понятно, как и синхронный"]', 'KOTLIN', 0, 0, 'Корутины — это мощный инструмент для асинхронного программирования, который позволяет писать асинхронный код почти так же просто и понятно, как и синхронный. Они обеспечивают удобный и эффективный способ работы с многозадачностью и параллелизмом в Kotlin.'),
                    ('Какие основные характеристики и преимущества у корутин?', '', '["Корутины позволяют запускать тысячи параллельных операций, потребляя гораздо меньше ресурсов по сравнению с традиционными потоками", "С помощью корутин можно писать асинхронный код, который выглядит как обычный синхронный код", "Корутины предоставляют механизмы для управления асинхронными операциями, такие как отмена операций, тайм-ауты и обработка ошибок", "Корутины автоматически управляют жизненным циклом потоков", "Корутины полностью совместимы со всеми существующими библиотеками Java"]', '["Корутины позволяют запускать тысячи параллельных операций, потребляя гораздо меньше ресурсов по сравнению с традиционными потоками", "С помощью корутин можно писать асинхронный код, который выглядит как обычный синхронный код", "Корутины предоставляют механизмы для управления асинхронными операциями, такие как отмена операций, тайм-ауты и обработка ошибок"]', 'KOTLIN', 0, 0, 'Основные характеристики и преимущества корутин включают: возможность запускать тысячи параллельных операций, потребляя гораздо меньше ресурсов по сравнению с традиционными потоками, написание асинхронного кода, который выглядит как обычный синхронный код, и предоставление механизмов для управления асинхронными операциями, таких как отмена операций, тайм-ауты и обработка ошибок.'),
                    ('Какие ключевые компоненты у корутин?', '', '["Coroutine Scope", "Coroutine Context", "Dispatchers", "Builders", "Coroutine Functions", "Coroutine Handlers"]', '["Coroutine Scope", "Coroutine Context", "Dispatchers", "Builders"]', 'KOTLIN', 0, 0, 'Ключевые компоненты корутин включают: `Coroutine Scope`, который управляет временем жизни корутин, `Coroutine Context`, который задает контекст выполнения корутин, `Dispatchers`, которые определяют потоки, на которых корутины выполняются, и `Builders`, которые используются для создания корутин (например, `launch` и `async`).'),
                    ('Что представляет собой Coroutine Context?', '', '["Job", "Dispatchers", "CoroutineName", "ExceptionHandler", "CoroutineScope", "CoroutineBuilder"]', '["Job", "Dispatchers", "CoroutineName", "ExceptionHandler"]', 'KOTLIN', 0, 0, '`Coroutine Context` представляет собой набор элементов, которые определяют контекст выполнения корутины. Включает в себя `Job` (управляет временем жизни корутины), `Dispatchers` (определяет потоки для выполнения корутин), `CoroutineName` (позволяет задать имя корутине для удобства отладки) и `ExceptionHandler` (обрабатывает необработанные исключения в корутине).'),
                    ('Для чего нужен Coroutine Scope?', '', '["Определяет контекст выполнения корутины, управляя её жизненным циклом", "Устанавливает приоритеты выполнения корутин", "Регулирует доступ к ресурсам между корутинами", "Обеспечивает синхронизацию между корутинами"]', '["Определяет контекст выполнения корутины, управляя её жизненным циклом"]', 'KOTLIN', 0, 0, '`Coroutine Scope` необходим для определения контекста выполнения корутины и управления её жизненным циклом. Он позволяет контролировать, когда корутина должна быть отменена и обеспечивает управление временем жизни корутин, группируя их и предоставляя возможность отмены всех корутин, связанных с данным `Scope`.'),
                    ('Для чего нужны Dispatchers у корутин?', '', '["Они помогают управлять потоками, на которых выполняются корутины", "Они задают приоритеты для корутин", "Они обеспечивают синхронизацию между корутинами", "Они задают время выполнения корутин"]', '["Они помогают управлять потоками, на которых выполняются корутины"]', 'KOTLIN', 0, 0, '`Dispatchers` у корутин нужны для управления потоками, на которых выполняются корутины. Они определяют, на каком потоке или пуле потоков будет выполняться код корутины, позволяя эффективно распределять выполнение задач и управлять асинхронностью. Примеры `Dispatchers` включают `Dispatchers.Main` для работы в главном потоке, `Dispatchers.IO` для ввода-вывода и `Dispatchers.Default` для выполнения фоновых задач.'),
                    ('Что такое Builders у корутин?', '', '["Функции, которые используются для запуска корутин", "Функции для управления жизненным циклом корутин", "Методы для настройки контекста выполнения корутин", "Инструменты для обработки ошибок в корутинах"]', '["Функции, которые используются для запуска корутин"]', 'KOTLIN', 0, 0, 'Builders у корутин — это функции, которые используются для запуска корутин. Они упрощают создание корутин и управление их выполнением. Основные функции-строители включают `launch` для запуска корутины, которая возвращает `Job`, и `async` для запуска корутины, которая возвращает `Deferred` для получения результата. Builders помогают определить контекст выполнения и поведение корутин.'),
                    ('Какие бывают Dispatchers?', '', '["Dispatchers.Main", "Dispatchers.IO", "Dispatchers.Default", "Dispatchers.Main.Immediate", "Dispatchers.Unconfined", "Dispatchers.Background"]', '["Dispatchers.Main", "Dispatchers.IO", "Dispatchers.Default", "Dispatchers.Main.Immediate", "Dispatchers.Unconfined"]', 'KOTLIN', 0, 0, 'Основные `Dispatchers` включают: `Dispatchers.Main`, который используется для выполнения корутин на главном потоке; `Dispatchers.IO`, предназначенный для операций ввода-вывода; `Dispatchers.Default`, предназначенный для выполнения фоновых задач и вычислительно сложных операций; `Dispatchers.Main.Immediate`, который выполняет корутины сразу на главном потоке, если они уже выполняются; и `Dispatchers.Unconfined`, который начинает выполнение корутины в текущем потоке и может переключаться на другой поток. Эти `Dispatchers` помогают управлять выполнением корутин и их распределением по потокам.'),
                    ('Для чего нужен Dispatchers.Main?', '', '["Для выполнения корутин на главном потоке", "Для выполнения фоновых задач и ввода-вывода", "Для выполнения вычислительно сложных операций", "Для обработки асинхронных операций в фоновом режиме"]', '["Для выполнения корутин на главном потоке"]', 'KOTLIN', 0, 0, '`Dispatchers.Main` нужен для выполнения корутин на главном потоке. Это позволяет корутинам обновлять пользовательский интерфейс и взаимодействовать с другими компонентами, которые требуют выполнения на основном потоке приложения.'),
                    ('Для чего нужен Dispatchers.IO?', '', '["Для чтения/записи данных", "Для выполнения корутин на главном потоке", "Для выполнения вычислительно сложных операций", "Для обработки асинхронных операций в фоновом режиме"]', '["Для чтения/записи данных"]', 'KOTLIN', 0, 0, '`Dispatchers.IO` нужен для выполнения корутин, связанных с операциями ввода-вывода, таких как чтение и запись данных, работа с файлами, сетевые запросы и другие длительные операции ввода-вывода. Этот диспетчер оптимизирован для таких задач и позволяет выполнять их асинхронно.'),
                    ('Сколько максимум потоков может занимать Dispatchers.IO?', '', '["64", "128", "32", "Столько, сколько ядер в процессоре"]', '["64"]', 'KOTLIN', 0, 0, '`Dispatchers.IO` может использовать до 64 потоков одновременно. Это позволяет эффективно обрабатывать множество операций ввода-вывода, которые могут выполняться параллельно, не блокируя основной поток и обеспечивая асинхронность.'),
                    ('Для чего нужен Dispatchers.Default?', '', '["Для выполнения сложных вычислений", "Для выполнения корутин на главном потоке", "Для чтения/записи данных", "Для обработки асинхронных операций в фоновом режиме"]', '["Для выполнения сложных вычислений"]', 'KOTLIN', 0, 0, '`Dispatchers.Default` нужен для выполнения сложных вычислительных операций и задач, требующих значительных ресурсов процессора. Этот диспетчер оптимизирован для работы с фоновыми задачами, которые могут быть вычислительно интенсивными, такими как обработка данных и выполнение параллельных вычислений.'),
                    ('Для чего нужен Dispatchers.Main.Immediate?', '', '["Для немедленного выполнения задачи на главном потоке", "Для выполнения корутин в фоновом режиме", "Для управления потоками ввода-вывода", "Для выполнения вычислительно сложных задач"]', '["Для немедленного выполнения задачи на главном потоке"]', 'KOTLIN', 0, 0, '`Dispatchers.Main.Immediate` нужен для немедленного выполнения корутины на главном потоке, если это возможно. Этот диспетчер позволяет корутине начать выполнение сразу же на главном потоке, а не ждать, пока поток освободится, что может улучшить отзывчивость пользовательского интерфейса.'),
                    ('Для чего нужен Dispatchers.Unconfined?', '', '["Для выполнения на том же потоке, на котором был вызван код", "Для выполнения корутин на главном потоке", "Для выполнения фоновых задач", "Для выполнения вычислительно сложных операций"]', '["Для выполнения на том же потоке, на котором был вызван код"]', 'KOTLIN', 0, 0, '`Dispatchers.Unconfined` используется для выполнения корутин на том же потоке, на котором был вызван код, и может переключаться на другой поток, если корутина продолжает выполнение в другом контексте. Этот диспетчер полезен, когда требуется, чтобы корутина начинала выполнение немедленно на текущем потоке и могла переходить между потоками в процессе выполнения.'),
                    ('Сколько максимум потоков может использовать Dispatchers.Default?', '', '["Столько, сколько ядер в процессоре", "64", "128", "32"]', '["Столько, сколько ядер в процессоре"]', 'KOTLIN', 0, 0, '`Dispatchers.Default` может использовать столько потоков, сколько ядер в процессоре. Это позволяет эффективно распределять вычислительные задачи по доступным ядрам и максимизировать использование процессорных ресурсов.'),
                    ('Какие существуют функции для запуска корутин?', '', '["launch", "async", "runBlocking", "produce", "actor"]', '["launch", "async", "runBlocking"]', 'KOTLIN', 0, 0, 'Основные функции для запуска корутин включают: `launch`, который запускает корутину без возврата результата и возвращает `Job`, и `async`, который запускает корутину и возвращает `Deferred`, позволяя получать результат в будущем. Также используется функция `runBlocking`, которая блокирует текущий поток до завершения корутин и часто используется в тестах и инициализации.'),
                    ('В чем отличие launch от async?', '', '["async позволяет получить результат асинхронной операции, возвращая Deferred", "launch возвращает результат операции, а async - Job", "launch возвращает Deferred, а async - Job", "async предназначен для запуска корутин в главном потоке, а launch - в фоновом"]', '["async позволяет получить результат асинхронной операции, возвращая Deferred", "launch возвращает Job, а async - Deferred"]', 'KOTLIN', 0, 0, '`launch` и `async` оба используются для запуска корутин, но с разными целями. `async` позволяет получить результат асинхронной операции, возвращая `Deferred`, который представляет собой значение, которое будет доступно в будущем. `launch`, с другой стороны, запускает корутину и возвращает `Job`, который представляет собой корутину без результата. Таким образом, `async` используется для корутин, которые возвращают результат, тогда как `launch` используется для корутин, которые выполняют операции без возврата значения.'),
                    ('Что такое inline функции?', '', '["Специальный тип функций, при компиляции которых код функции встраивается в место её вызова", "Функции, которые выполняются асинхронно", "Функции, которые оптимизируют доступ к базе данных", "Функции, которые выполняются в отдельном потоке"]', '["Специальный тип функций, при компиляции которых код функции встраивается в место её вызова"]', 'KOTLIN', 0, 0, 'Inline функции — это специальный тип функций, при компиляции которых код функции встраивается в место её вызова. Это может уменьшить накладные расходы на вызов функции и повысить производительность, особенно для функций, которые часто вызываются и имеют небольшую реализацию.'),
                    ('Для чего нужны inline функции?', '', '["Уменьшение дополнительных расходов на вызов функций, за счет того, что не происходит дополнительных вызовов функций и не создаётся новый стек", "Улучшение производительности при использовании лямбда-выражений", "Возможность использования некоторых специфичных возможностей языка (например, reified type parameters)", "Оптимизация работы с потоками", "Повышение уровня абстракции кода"]', '["Уменьшение дополнительных расходов на вызов функций, за счет того, что не происходит дополнительных вызовов функций и не создаётся новый стек", "Улучшение производительности при использовании лямбда-выражений", "Возможность использования некоторых специфичных возможностей языка (например, reified type parameters)"]', 'KOTLIN', 0, 0, 'Inline функции нужны для уменьшения дополнительных расходов на вызов функций, так как их код встраивается в место вызова, что позволяет избежать дополнительных вызовов и создания нового стека. Это также улучшает производительность при использовании лямбда-выражений и позволяет использовать специфичные возможности языка, такие как `reified` типы параметров, которые требуют знания типа на этапе компиляции.'),
                    ('Какие утверждения верны про реифицированные типовые параметры?', '', '["Реификация позволяет сохранять информацию о типах параметров и использовать её на этапе выполнения", "Реификация позволяет выполнять операции, которые зависят от конкретных типов, сохраняя типовую информацию, доступную в runtime", "Реификация делает типовые параметры доступными только на этапе компиляции", "Реификация приводит к увеличению накладных расходов из-за необходимости сохранения типовой информации"]', '["Реификация позволяет сохранять информацию о типах параметров и использовать её на этапе выполнения", "Реификация позволяет выполнять операции, которые зависят от конкретных типов, сохраняя типовую информацию, доступную в runtime"]', 'KOTLIN', 0, 0, 'Реифицированные типовые параметры позволяют сохранять информацию о типах параметров и использовать её на этапе выполнения, что позволяет выполнять операции, зависящие от конкретных типов. Это позволяет типовой информации быть доступной в runtime, что не так при использовании обычных обобщений, где типовая информация теряется после компиляции.'),
                    ('Какие утверждения про inline функции верны?', '', '["Использование inline функций увеличивает размер скомпилированного кода, так как код функции копируется в каждое место её вызова", "Не все функции стоит делать inline. Преимущества инлайнинга наиболее заметны для небольших функций и функций, принимающих лямбда-выражения", "Inline функции могут содержать реифицированные типовые параметры, что невозможно в обычных функциях из-за стирания типов во время выполнения в JVM", "Inline функции не могут быть использованы с лямбда-выражениями", "Inline функции замедляют выполнение программы"]', '["Использование inline функций увеличивает размер скомпилированного кода, так как код функции копируется в каждое место её вызова", "Не все функции стоит делать inline. Преимущества инлайнинга наиболее заметны для небольших функций и функций, принимающих лямбда-выражения", "Inline функции могут содержать реифицированные типовые параметры, что невозможно в обычных функциях из-за стирания типов во время выполнения в JVM"]', 'KOTLIN', 0, 0, 'Верные утверждения про inline функции включают: использование inline функций увеличивает размер скомпилированного кода, так как код функции копируется в каждое место её вызова; не все функции стоит делать inline, так как преимущества инлайнинга наиболее заметны для небольших функций и функций, принимающих лямбда-выражения; и inline функции могут содержать реифицированные типовые параметры, что невозможно в обычных функциях из-за стирания типов во время выполнения в JVM.'),
                    ('Что такое HashMap?', '', '["Структура данных, которая позволяет хранить пары ключ-значение", "Структура данных, которая хранит элементы в отсортированном порядке", "Структура данных, которая реализует очередь с приоритетом", "Структура данных, которая хранит элементы в виде связанного списка"]', '["Структура данных, которая позволяет хранить пары ключ-значение"]', 'JAVA', 0, 0, 'HashMap — это структура данных, которая позволяет хранить пары ключ-значение. Она реализует интерфейс `Map` и обеспечивает быстрый доступ к элементам на основе ключей, используя хеширование для оптимизации операций поиска, вставки и удаления.'),
                    ('Выберете все утверждения, которые верны про работу HashMap:', '', '["При добавлении пару ключ-значение в него, ключ сначала обрабатывается хэш-функцией, которая вычисляет хэш-код", "HashMap управляет коллизиями, используя список (или другую структуру данных, например, красно-черное дерево) для хранения всех пар, которые попадают в одну и ту же ячейку массива", "Когда коэффициент заполнения становится слишком высоким, происходит рехеширование, где создается новый, больший массив, и все текущие элементы перераспределяются по новому массиву согласно их хэш-кодам", "HashMap хранит элементы в отсортированном порядке"]', '["При добавлении пару ключ-значение в него, ключ сначала обрабатывается хэш-функцией, которая вычисляет хэш-код", "HashMap управляет коллизиями, используя список (или другую структуру данных, например, красно-черное дерево) для хранения всех пар, которые попадают в одну и ту же ячейку массива", "Когда коэффициент заполнения становится слишком высоким, происходит рехеширование, где создается новый, больший массив, и все текущие элементы перераспределяются по новому массиву согласно их хэш-кодам"]', 'JAVA', 0, 0, 'Верные утверждения про работу `HashMap` включают: при добавлении пары ключ-значение, ключ сначала обрабатывается хэш-функцией, которая вычисляет хэш-код; `HashMap` управляет коллизиями, используя список (или другую структуру данных, например, красно-черное дерево) для хранения всех пар, которые попадают в одну и ту же ячейку массива; и когда коэффициент заполнения становится слишком высоким, происходит рехеширование, создается новый, больший массив, и все текущие элементы перераспределяются по новому массиву согласно их хэш-кодам.'),
                    ('Как происходит добавление элемента в HashMap?', '', '["Ключ обрабатывается для создания хэш-кода, определяется индекс для хранения значения в массиве. Если в этом индексе уже есть элементы, новая пара добавляется в список.", "Ключи и значения автоматически сортируются по алфавиту перед добавлением в массив.", "Каждый элемент в массиве хранится в виде дерева, где ключи отсортированы по значению.", "Новая пара ключ-значение заменяет существующее значение, если ключ уже присутствует в `HashMap`."]', '["Ключ обрабатывается для создания хэш-кода, определяется индекс для хранения значения в массиве. Если в этом индексе уже есть элементы, новая пара добавляется в список."]', 'JAVA', 0, 0, 'При добавлении элемента в `HashMap` ключ обрабатывается для создания хэш-кода, который используется для определения индекса в массиве. Если в этом индексе уже есть элементы (из-за коллизий), новая пара ключ-значение добавляется в список или другую структуру данных, связанную с этим индексом.'),
                    ('Как происходит поиск элемента в HashMap?', '', '["Ключ обрабатывается для создания хэш-кода, определяется индекс, и если в этом месте есть список, то происходит поиск нужной пары по ключу в списке.", "Ключи сортируются перед поиском, и используется бинарный поиск для нахождения нужного элемента.", "Поиск выполняется по всему массиву, независимо от хэш-кода, чтобы найти нужный элемент.", "Поиск осуществляется только в том случае, если массив не пустой."]', '["Ключ обрабатывается для создания хэш-кода, определяется индекс, и если в этом месте есть список, то происходит поиск нужной пары по ключу в списке."]', 'JAVA', 0, 0, 'Поиск элемента в `HashMap` происходит следующим образом: ключ обрабатывается для создания хэш-кода, который используется для определения индекса в массиве. Если в этом индексе уже есть список (в случае коллизий), то происходит поиск нужной пары ключ-значение в этом списке, чтобы найти элемент с соответствующим ключом.'),
                    ('Как происходит удаление элемента в HashMap?', '', '["Ключ обрабатывается для создания хэш-кода, определяется индекс, и если в этом месте есть список, то происходит поиск нужной пары по ключу в списке и после поиска она удаляется из списка", "Удаление элемента происходит путем сортировки всех элементов в массиве и удаления нужного элемента", "Удаление элемента приводит к автоматическому уменьшению размера массива и перераспределению элементов", "Удаление элемента не затрагивает другие элементы и не вызывает перераспределение массива"]', '["Ключ обрабатывается для создания хэш-кода, определяется индекс, и если в этом месте есть список, то происходит поиск нужной пары по ключу в списке и после поиска она удаляется из списка"]', 'JAVA', 0, 0, 'Удаление элемента в `HashMap` происходит следующим образом: ключ обрабатывается для создания хэш-кода, который определяет индекс в массиве. Если в этом индексе есть список (из-за коллизий), то выполняется поиск нужной пары ключ-значение в этом списке, и после нахождения элемента он удаляется из списка. Это позволяет освободить место в структуре данных и сохранить корректность `HashMap`.'),
                    ('Что такое хэш-код?', '', '["Целое число, и оно используется для определения индекса во внутреннем массиве, где должна храниться пара", "Десятичное число, используемое для определения порядка элементов в списке", "Функция, которая вычисляет уникальные значения для каждого объекта", "Строка, представляющая уникальный идентификатор объекта"]', '["Целое число, и оно используется для определения индекса во внутреннем массиве, где должна храниться пара"]', 'JAVA', 0, 0, 'Хэш-код — это целое число, вычисляемое для объекта, которое используется для определения индекса в внутреннем массиве, где должна храниться пара ключ-значение в `HashMap`. Это позволяет быстро находить элементы в структуре данных за счет использования хэширования.'),
                    ('Что такое коллизия?', '', '["Когда два разных ключа могут дать один и тот же хэш-код, или разные хэш-коды могут свести к одному и тому же индексу массива из-за ограниченного размера массива", "Когда два ключа имеют разные хэш-коды, но совпадают в значении", "Когда хэш-код не совпадает с индексом в массиве, несмотря на то что ключи различны", "Когда ключи упорядочены по хэш-коду, но хэш-код для одного ключа повторяется"]', '["Когда два разных ключа могут дать один и тот же хэш-код, или разные хэш-коды могут свести к одному и тому же индексу массива из-за ограниченного размера массива"]', 'JAVA', 0, 0, 'Коллизия — это ситуация, когда два разных ключа могут дать один и тот же хэш-код, или когда разные хэш-коды ведут к одному и тому же индексу в массиве, из-за ограниченного размера массива. Это приводит к необходимости использовать дополнительные структуры данных для разрешения коллизий и обеспечения корректного хранения и поиска элементов в `HashMap`.'),
                    ('Сколько бакетов создает HashMap по умолчанию?', '', '["16", "32", "64", "8"]', '["16"]', 'JAVA', 0, 0, 'По умолчанию `HashMap` создает 16 бакетов (или слотов) в своем внутреннем массиве для хранения элементов. Этот параметр может быть изменен при создании `HashMap`, но стандартное значение — 16.'),
                    ('Какой порог загрузки имеет HashMap по умолчанию?', '', '["0.75", "0.5", "1.0", "0.25"]', '["0.75"]', 'JAVA', 0, 0, 'По умолчанию порог загрузки (или коэффициент заполнения) `HashMap` установлен на 0.75. Это означает, что когда `HashMap` заполняется до 75% от своего текущего размера, происходит рехеширование, чтобы увеличить размер массива и уменьшить вероятность коллизий.'),
                    ('Во сколько раз увеличивается новый массив после рехеширования?', '', '["2", "4", "1.5", "3"]', '["2"]', 'JAVA', 0, 0, 'После рехеширования размер массива в `HashMap` увеличивается в два раза. Это помогает уменьшить количество коллизий и улучшить производительность операций вставки, удаления и поиска.'),
                    ('Какое среднее время для операций вставки, удаления и поиска элементов в HashMap?', '', '["O(1)", "O(n)", "O(log n)", "O(n^2)"]', '["O(1)"]', 'JAVA', 0, 0, 'Среднее время для операций вставки, удаления и поиска элементов в `HashMap` составляет O(1). Это связано с тем, что `HashMap` использует хэширование для быстрого доступа к элементам. Однако в случае коллизий время может увеличиваться, но среднее время остаётся O(1).'),
                    ('В каком случае производительность HashMap может упасть до O(n)?', '', '["В случае коллизий", "При использовании большого количества памяти", "При работе с большими массивами", "При многопоточном доступе"]', '["В случае коллизий"]', 'JAVA', 0, 0, 'Производительность `HashMap` может упасть до O(n) в случае частых коллизий. Это происходит, когда множество ключей имеют одинаковый хэш-код или ведут к одному и тому же индексу в массиве, что приводит к увеличению времени поиска, так как элементы хранятся в виде списка или другой структуры данных, требующей линейного поиска.'),
                    ('Для чего нужен Manifest?', '', '["В нём объявляются основные компоненты приложения, требуемые разрешения, поддерживаемые устройственные конфигурации и другие метаданные.", "Для хранения пользовательских данных приложения", "Для выполнения кода при запуске приложения", "Для определения стилей и тем приложения"]', '["В нём объявляются основные компоненты приложения, требуемые разрешения, поддерживаемые устройственные конфигурации и другие метаданные."]', 'ANDROID', 0, 0, 'Файл `AndroidManifest.xml` используется для объявления основных компонентов приложения, таких как активности, сервисы, ресиверы и провайдеры контента. В нём также указываются требуемые разрешения, поддерживаемые конфигурации устройств и другие метаданные, которые необходимы системе для правильной работы приложения.'),
                    ('Какие ключевые аспекты, для которых необходим Manifest?', '', '["Объявление компонентов приложения", "Запрос системных разрешений", "Определение уровня API", "Объявление библиотек", "Установка фильтров интентов (`<intent-filter>`)", "Конфигурация приложения (иконка, название, тема оформления и другие атрибуты)"]', '["Объявление компонентов приложения", "Запрос системных разрешений", "Установка фильтров интентов (`<intent-filter>`)", "Конфигурация приложения (иконка, название, тема оформления и другие атрибуты)"]', 'ANDROID', 0, 0, 'Файл `AndroidManifest.xml` используется для нескольких ключевых аспектов приложения, включая: объявление компонентов приложения (активностей, сервисов, ресиверов и провайдеров контента), запрос системных разрешений, установку фильтров интентов для определения того, какие действия могут обрабатывать компоненты приложения, и конфигурацию приложения (иконка, название, тема оформления и другие атрибуты).'),
                    ('Что представляет собой тип Any?', '', '["Корневой тип для всех ненулевых типов, аналог Object из Java", "Тип, представляющий любые значения, включая null", "Тип, предназначенный для хранения числовых значений", "Тип, представляющий только строковые значения"]', '["Корневой тип для всех ненулевых типов, аналог Object из Java"]', 'KOTLIN', 0, 0, 'В Kotlin тип `Any` представляет собой корневой тип для всех ненулевых типов, аналог типа `Object` из Java. Он служит базой для всех классов, кроме `Nothing` и `Nullable` типов, обеспечивая универсальность для хранения значений различных типов.'),
                    ('Какие методы определяет Any?', '', '["equals()", "hashCode()", "toString()", "clone()", "compareTo()"]', '["equals()", "hashCode()", "toString()"]', 'KOTLIN', 0, 0, 'Тип `Any` в Kotlin определяет три основных метода: `equals()`, `hashCode()` и `toString()`. Эти методы предоставляют базовые функциональные возможности для сравнения объектов, генерации их хэш-кодов и получения строкового представления.'),
                    ('Какие утверждения про Unit верны?', '', '["Аналог void из Java", "Является возвращаемым типом для всех функций, которые не возвращают значимый результат", "Используется для указания, что функция выполняет действие, но не возвращает значение", "Возвращаемый тип `Unit` обычно опускается, но его можно указать", "Unit может иметь значения и не обязательно возвращать пустое значение", "Функции, возвращающие `Unit`, всегда должны завершаться с `return`"]', '["Аналог void из Java", "Является возвращаемым типом для всех функций, которые не возвращают значимый результат", "Используется для указания, что функция выполняет действие, но не возвращает значение", "Возвращаемый тип `Unit` обычно опускается, но его можно указать"]', 'KOTLIN', 0, 0, 'Тип `Unit` в Kotlin представляет собой аналог `void` из Java. Он используется в функциях, которые не возвращают значимый результат, указывая, что функция выполняет действие, но не возвращает значение. Хотя возвращаемый тип `Unit` обычно опускается в декларациях функций, его можно явно указать. Неверно, что `Unit` может иметь значения — он всегда представляет отсутствие значимого значения. Также неверно, что функции, возвращающие `Unit`, всегда должны завершаться с `return` — это не обязательно.'),
                    ('Что такое Garbage Collector?', '', '["Механизм управления памятью, который автоматически освобождает память, выделенную для объектов, которые больше не используются в программе.", "Инструмент для ручного управления памятью, позволяющий освобождать память по запросу.", "Метод оптимизации производительности путем удаления ненужных данных из оперативной памяти.", "Механизм, позволяющий выделять больше памяти для приложения при необходимости."]', '["Механизм управления памятью, который автоматически освобождает память, выделенную для объектов, которые больше не используются в программе."]', 'BASE', 0, 0, 'Garbage Collector (GC) — это механизм управления памятью, который автоматически освобождает память, выделенную для объектов, которые больше не используются в программе. Это позволяет уменьшить утечки памяти и оптимизировать использование ресурсов.'),
                    ('Как работает Garbage Collector?', '', '["Сканирует объекты, доступные из корневого набора (например, переменные на стеке, статические переменные), и помечает все объекты, которые можно достичь напрямую или косвенно, как \"живые\", сборщик проходит по всей куче (heap) памяти и освобождает память, занимаемую объектами, которые не были помечены как \"живые\".", "Ручное управление памятью, где разработчик явно освобождает память для объектов, которые больше не нужны.", "Сборка всех объектов одновременно и удаление всех объектов, которые были созданы в определенный период времени.", "Определение и удаление объектов только при достижении предела использования памяти"]', '["Сканирует объекты, доступные из корневого набора (например, переменные на стеке, статические переменные), и помечает все объекты, которые можно достичь напрямую или косвенно, как \"живые\", сборщик проходит по всей куче (heap) памяти и освобождает память, занимаемую объектами, которые не были помечены как \"живые\"."]', 'BASE', 0, 0, 'Garbage Collector работает, сканируя объекты, доступные из корневого набора (например, переменные на стеке, статические переменные), и помечает все объекты, которые можно достичь напрямую или косвенно, как "живые". После этого сборщик проходит по всей куче (heap) памяти и освобождает память, занимаемую объектами, которые не были помечены как "живые". Это помогает управлять памятью автоматически, минимизируя утечки и оптимизируя использование ресурсов.'),
                    ('Какие преимущества у сборщика мусора?', '', '["Автоматическое управление памятью значительно снижает риск таких ошибок, как утечки памяти (когда память выделяется, но не освобождается) и двойное освобождение памяти (когда память освобождается более одного раза)", "Не нужно тратить время на явное управление памятью", "Гарbage Collector может увеличить производительность приложения, так как освобождение памяти происходит более эффективно, чем при ручном управлении", "Сборщик мусора всегда гарантирует, что вся память будет освобождена до выхода из приложения"]', '["Автоматическое управление памятью значительно снижает риск таких ошибок, как утечки памяти (когда память выделяется, но не освобождается) и двойное освобождение памяти (когда память освобождается более одного раза)", "Не нужно тратить время на явное управление памятью"]', 'BASE', 0, 0, 'Преимущества сборщика мусора включают автоматическое управление памятью, что значительно снижает риск ошибок, таких как утечки памяти и двойное освобождение памяти. Это также позволяет разработчикам не тратить время на явное управление памятью, упрощая процесс разработки. Однако сборщик мусора не всегда гарантирует, что вся память будет освобождена до выхода из приложения и не всегда увеличивает производительность, так как процесс сборки может повлиять на производительность приложения.'),
                    ('Какие недостатки у сборщика мусора?', '', '["Сборка мусора может произойти в любой момент времени, что может привести к кратковременным задержкам в выполнении программы, особенно если сборка мусора занимает много времени", "Сборка мусора потребляет системные ресурсы, такие как процессорное время и память, что может снизить общую производительность приложения", "Сборщик мусора не может полностью устранить все утечки памяти, что может потребовать дополнительного ручного управления памятью", "Сборка мусора может повысить сложность кода, так как разработчик должен учитывать время и ресурсы, затраченные на сборку мусора"]', '["Сборка мусора может произойти в любой момент времени, что может привести к кратковременным задержкам в выполнении программы, особенно если сборка мусора занимает много времени", "Сборка мусора потребляет системные ресурсы, такие как процессорное время и память, что может снизить общую производительность приложения"]', 'BASE', 0, 0, 'Недостатки сборщика мусора включают возможность возникновения кратковременных задержек в выполнении программы, когда сборка мусора происходит в неподходящий момент и занимает много времени. Также сборка мусора потребляет системные ресурсы, такие как процессорное время и память, что может снизить общую производительность приложения. Несмотря на то, что сборщик мусора облегчает управление памятью, он не всегда может полностью устранить утечки памяти, и разработчику может понадобиться дополнительное ручное управление памятью.'),
                    ('Чем data class отличается от обычного класса?', '', '["При объявлении data class, компилятор автоматически генерирует методы `equals()`, `hashCode()`, `toString()`, `copy()`", "Data class не может быть абстрактным, открытым (`open`), запечатанным (`sealed`) или внутренним (`inner`)", "В data class должен быть хотя бы один параметр в первичном конструкторе, и все эти параметры должны быть помечены как `val` или `var`", "Обычные классы используются для более широкого спектра задач, включая реализацию бизнес-логики и других функциональностей, которые не ограничиваются только хранением данных", "Data class имеет доступ ко всем методам и свойствам, доступным для обычных классов", "Data class может быть использован для реализации сложной бизнес-логики и хранения состояния"]', '["При объявлении data class, компилятор автоматически генерирует методы `equals()`, `hashCode()`, `toString()`, `copy()`", "Data class не может быть абстрактным, открытым (`open`), запечатанным (`sealed`) или внутренним (`inner`)", "В data class должен быть хотя бы один параметр в первичном конструкторе, и все эти параметры должны быть помечены как `val` или `var`", "Обычные классы используются для более широкого спектра задач, включая реализацию бизнес-логики и других функциональностей, которые не ограничиваются только хранением данных"]', 'KOTLIN', 0, 0, 'Основные отличия data class от обычного класса заключаются в следующем: при объявлении data class компилятор автоматически генерирует методы `equals()`, `hashCode()`, `toString()`, и `copy()`. Кроме того, data class не может быть абстрактным, открытым (`open`), запечатанным (`sealed`) или внутренним (`inner`). В data class должен быть хотя бы один параметр в первичном конструкторе, и все эти параметры должны быть помечены как `val` или `var`. Обычные классы же могут использоваться для более широкого спектра задач, включая реализацию бизнес-логики и других функциональностей, которые не ограничиваются только хранением данных.'),
                    ('Что такое LinkedList?', '', '["Структура данных, которая представляет собой список элементов, связанных между собой. Каждый элемент списка (узел) содержит данные и ссылку на следующий (и/или предыдущий) узел в списке", "Структура данных, которая представляет собой массив фиксированного размера, где каждый элемент имеет свой индекс", "Структура данных, которая хранит элементы в виде деревьев, где каждый узел имеет ссылки на свои дочерние узлы", "Структура данных, которая организует элементы в виде хэш-таблицы для обеспечения быстрого доступа"]', '["Структура данных, которая представляет собой список элементов, связанных между собой. Каждый элемент списка (узел) содержит данные и ссылку на следующий (и/или предыдущий) узел в списке"]', 'BASE', 0, 0, 'LinkedList — это структура данных, которая представляет собой список элементов, связанных между собой. Каждый элемент списка, называемый узлом, содержит данные и ссылку на следующий (и/или предыдущий) узел в списке. Это позволяет эффективно вставлять и удалять элементы в середине списка.'),
                    ('Из чего состоит LinkedList?', '', '["Каждый элемент представлен узлом, который содержит данные и ссылку на следующий (или предыдущий в случае двусвязного списка) узел", "Каждый элемент представляет собой индексированный массив, где элементы расположены в фиксированном порядке", "Каждый элемент представляет собой бинарное дерево, где узлы имеют ссылки на свои дочерние узлы", "Каждый элемент представлен парой ключ-значение, хранящейся в хэш-таблице"]', '["Каждый элемент представлен узлом, который содержит данные и ссылку на следующий (или предыдущий в случае двусвязного списка) узел"]', 'BASE', 0, 0, 'LinkedList состоит из узлов, где каждый узел содержит данные и ссылку на следующий (и/или предыдущий в случае двусвязного списка) узел. Это позволяет эффективно вставлять и удалять элементы в середине списка.'),
                    ('Какие существуют типы LinkedList?', '', '["Односвязный список: Каждый узел имеет ссылку только на следующий узел", "Двусвязный список: Каждый узел имеет ссылки на следующий и предыдущий узел, что позволяет двигаться в обе стороны", "Циклический список: Последний узел в списке указывает на первый узел, создавая замкнутый круг", "Массивный список: Список хранит элементы в виде фиксированного размера массива", "Бинарное дерево: Список организован в виде узлов, где каждый узел имеет ссылки на два дочерних узла"]', '["Односвязный список: Каждый узел имеет ссылку только на следующий узел", "Двусвязный список: Каждый узел имеет ссылки на следующий и предыдущий узел, что позволяет двигаться в обе стороны", "Циклический список: Последний узел в списке указывает на первый узел, создавая замкнутый круг"]', 'BASE', 0, 0, 'Существуют следующие типы LinkedList: односвязный список, где каждый узел имеет ссылку только на следующий узел; двусвязный список, где каждый узел имеет ссылки на следующий и предыдущий узел, что позволяет двигаться в обе стороны; и циклический список, где последний узел в списке указывает на первый узел, создавая замкнутый круг.'),
                    ('Как происходит вставка элемента в LinkedList?', '', '["Вставка нового элемента в список может происходить в любом месте (в начало, в конец или в середину) без необходимости перемещения других элементов", "Вставка элемента требует перемещения всех последующих элементов, чтобы освободить место для нового элемента", "Вставка элемента возможна только в начало или конец списка, а не в середину", "Вставка элемента требует поиска подходящего индекса, что делает её медленной"]', '["Вставка нового элемента в список может происходить в любом месте (в начало, в конец или в середину) без необходимости перемещения других элементов"]', 'BASE', 0, 0, 'Вставка нового элемента в LinkedList может происходить в любом месте (в начало, в конец или в середину) без необходимости перемещения других элементов, так как каждый узел содержит ссылки на соседние узлы. Это позволяет эффективно добавлять или удалять элементы в середине списка.'),
                    ('Как происходит удаление элемента в LinkedList?', '', '["Удаление элемента может происходить быстро, если имеется ссылка на узел, который необходимо удалить", "Удаление элемента требует перемещения всех последующих элементов, чтобы освободить место для нового элемента", "Удаление элемента возможно только в начало или конец списка, а не в середину", "Удаление элемента требует поиска подходящего индекса, что делает его медленным"]', '["Удаление элемента может происходить быстро, если имеется ссылка на узел, который необходимо удалить"]', 'BASE', 0, 0, 'Удаление элемента в LinkedList может происходить быстро, если имеется ссылка на узел, который необходимо удалить. В таком случае достаточно обновить ссылки у соседних узлов. Если ссылка на узел отсутствует, то требуется сначала поиск узла, что может увеличить время выполнения операции.'),
                    ('Как происходит поиск элемента в LinkedList?', '', '["Поиск элемента происходит медленнее по сравнению с массивами, так как требуется последовательное прохождение узлов, начиная с начала списка", "Поиск элемента осуществляется за постоянное время O(1), так как все элементы хранятся в одном массиве", "Поиск элемента может быть выполнен за время O(log n) благодаря использованию бинарного поиска", "Поиск элемента выполняется очень быстро, так как все элементы имеют ссылки на предыдущие и следующие узлы"]', '["Поиск элемента происходит медленнее по сравнению с массивами, так как требуется последовательное прохождение узлов, начиная с начала списка"]', 'BASE', 0, 0, 'Поиск элемента в LinkedList происходит медленнее по сравнению с массивами, так как требуется последовательное прохождение узлов, начиная с начала списка, пока не будет найден нужный элемент. Это приводит к времени выполнения операции O(n).'),
                    ('Какие преимущества у LinkedList?', '', '["Быстрая вставка элементов в произвольных местах", "Быстрое удаление элементов в произвольных местах", "Не требуется предварительное выделение памяти", "Быстрый доступ к элементам по индексу", "Меньше затрат на память по сравнению с массивами"]', '["Быстрая вставка элементов в произвольных местах", "Быстрое удаление элементов в произвольных местах", "Не требуется предварительное выделение памяти"]', 'BASE', 0, 0, 'Преимущества LinkedList включают быструю вставку и удаление элементов в произвольных местах, так как это не требует перемещения других элементов. Также не требуется предварительное выделение памяти, так как память выделяется по мере необходимости для каждого узла.'),
                    ('Какие недостатки у LinkedList?', '', '["Более высокие дополнительные расходы на память из-за хранения ссылок на узлы", "Медленный доступ к элементам по индексу, так как требуется последовательный обход узлов", "Быстрая вставка и удаление элементов в произвольных местах", "Меньшая гибкость в изменении размера по сравнению с массивами", "Потребление меньшего объема памяти по сравнению с массивами"]', '["Более высокие дополнительные расходы на память из-за хранения ссылок на узлы", "Медленный доступ к элементам по индексу, так как требуется последовательный обход узлов"]', 'BASE', 0, 0, 'Недостатки LinkedList включают более высокие дополнительные расходы на память из-за хранения ссылок на узлы, а также медленный доступ к элементам по индексу, так как требуется последовательный обход узлов. Эти факторы могут снизить эффективность работы с LinkedList по сравнению с массивами или другими структурами данных.'),
                    ('Какая производительность у вставки или удаления элемента в начале/конце у LinkedList?', '', '["O(1)", "O(n)", "O(log n)", "O(1) только для вставки, O(n) для удаления", "O(n) только для вставки, O(1) для удаления"]', '["O(1)"]', 'BASE', 0, 0, 'Вставка или удаление элемента в начале или конце LinkedList выполняется за время O(1), так как для этих операций достаточно обновить ссылки у соответствующих узлов. Это позволяет выполнять эти операции эффективно и быстро.'),
                    ('Какая производительность у поиска элемента у LinkedList?', '', '["O(n)", "O(1)", "O(log n)", "O(n^2)", "O(1) в среднем"]', '["O(n)"]', 'BASE', 0, 0, 'Поиск элемента в LinkedList имеет производительность O(n), так как требует последовательного обхода узлов от начала списка до нахождения нужного элемента. Это означает, что время выполнения операции пропорционально количеству элементов в списке.'),
                    ('Что такое ArrayList?', '', '["Динамический массив, который реализует интерфейс List и поддерживает динамическое изменение размера", "Статический массив фиксированного размера, который поддерживает быстрый доступ по индексу", "Структура данных для хранения пар ключ-значение, которая использует хэширование", "Стек, который поддерживает только операции добавления и удаления элементов с одного конца"]', '["Динамический массив, который реализует интерфейс List и поддерживает динамическое изменение размера"]', 'BASE', 0, 0, 'ArrayList — это динамический массив, который реализует интерфейс List и предназначен для хранения элементов с возможностью динамического изменения размера. В отличие от статического массива, размер ArrayList может изменяться по мере добавления или удаления элементов.'),
                    ('Какого размера массив ArrayList по умолчанию?', '', '["10", "16", "8", "0"]', '["10"]', 'JAVA', 0, 0, 'Размер массива ArrayList по умолчанию составляет 10. Это означает, что при создании ArrayList без указания начального размера, выделяется массив на 10 элементов.'),
                    ('Во сколько раз увеличивается размер массива ArrayList при расширении?', '', '["2", "1.5", "2.5", "3"]', '["2"]', 'JAVA', 0, 0, 'При расширении массива в ArrayList его размер увеличивается в 2 раза. Это позволяет эффективно управлять динамическим ростом списка, уменьшая количество операций копирования массива.'),
                    ('Какая производительность у вставки элемента в конец ArrayList?', '', '["O(1)", "O(n)", "O(log n)", "O(n log n)"]', '["O(1)"]', 'JAVA', 0, 0, 'Вставка элемента в конец ArrayList выполняется за время O(1), так как, если в массиве достаточно места, элемент добавляется в конец без необходимости перемещения других элементов.'),
                    ('Какая производительность у вставки элемента в произвольную позицию ArrayList?', '', '["O(n)", "O(1)", "O(log n)", "O(n log n)"]', '["O(n)"]', 'JAVA', 0, 0, 'Вставка элемента в произвольную позицию ArrayList выполняется за время O(n), так как необходимо перемещать все последующие элементы для освобождения места под новый элемент.'),
                    ('Какая производительность у удаления элемента ArrayList?', '', '["O(n)", "O(1)", "O(log n)", "O(n^2)"]', '["O(n)"]', 'JAVA', 0, 0, 'Удаление элемента из ArrayList имеет производительность O(n), так как после удаления элемента все последующие элементы нужно переместить для заполнения освобожденного места.'),
                    ('Какая производительность у итерации по элементам ArrayList?', '', '["O(n)", "O(1)", "O(log n)", "O(n^2)"]', '["O(n)"]', 'JAVA', 0, 0, 'Итерация по элементам ArrayList имеет производительность O(n), так как необходимо пройти через все элементы списка один за другим.'),
                    ('Какая производительность у поиска элемента ArrayList по индексу?', '', '["O(1)", "O(n)", "O(log n)", "O(n log n)"]', '["O(1)"]', 'JAVA', 0, 0, 'Поиск элемента в ArrayList по индексу имеет производительность O(1), так как доступ к элементу по индексу осуществляется напрямую через массив.'),
                    ('Выберите верные утверждения про сравнение ArrayList и LinkedList:', '', '["ArrayList более эффективен с точки зрения использования памяти по сравнению с LinkedList, так как LinkedList требует дополнительной памяти для хранения ссылок на следующий и предыдущий элементы списка для каждого элемента", "ArrayList идеально подходит для сценариев, где требуются частые операции чтения", "LinkedList предпочтительнее использовать, когда приложение выполняет много операций вставки и удаления", "LinkedList имеет лучшую производительность при доступе к элементам по индексу"]', '["ArrayList более эффективен с точки зрения использования памяти по сравнению с LinkedList, так как LinkedList требует дополнительной памяти для хранения ссылок на следующий и предыдущий элементы списка для каждого элемента", "ArrayList идеально подходит для сценариев, где требуются частые операции чтения", "LinkedList предпочтительнее использовать, когда приложение выполняет много операций вставки и удаления"]', 'JAVA', 0, 0, 'ArrayList более эффективен с точки зрения использования памяти по сравнению с LinkedList, так как LinkedList требует дополнительной памяти для хранения ссылок на следующий и предыдущий элементы списка для каждого элемента. ArrayList идеально подходит для сценариев, где требуются частые операции чтения. LinkedList предпочтительнее использовать, когда приложение выполняет много операций вставки и удаления.'),
                    ('Какие преимущества у ArrayList?', '', '["Быстрый доступ по индексу", "Автоматическое управление размером", "Меньший расход памяти по сравнению с LinkedList", "Поддержка методов коллекций", "Быстрое удаление элементов в произвольной позиции"]', '["Быстрый доступ по индексу", "Автоматическое управление размером", "Меньший расход памяти по сравнению с LinkedList", "Поддержка методов коллекций"]', 'JAVA', 0, 0, 'ArrayList предлагает быстрый доступ по индексу благодаря прямому доступу к элементам массива, автоматическое управление размером, меньший расход памяти по сравнению с LinkedList, так как не требуется хранить ссылки на соседние элементы, и поддержку методов коллекций. Однако, удаление элементов в произвольной позиции в ArrayList не является его преимуществом и может быть медленным.'),
                    ('Какие недостатки у ArrayList?', '', '["Медленная вставка и удаление элементов", "Проблемы с увеличением размера (затратная операция)", "Проблемы при удалении большого количества элементов", "ArrayList не является потокобезопасным и его использование в многопоточной среде требует внешней синхронизации", "Более высокое потребление памяти по сравнению с LinkedList"]', '["Медленная вставка и удаление элементов", "Проблемы с увеличением размера (затратная операция)", "Проблемы при удалении большого количества элементов", "ArrayList не является потокобезопасным и его использование в многопоточной среде требует внешней синхронизации"]', 'JAVA', 0, 0, 'Недостатки ArrayList включают медленную вставку и удаление элементов в произвольных позициях, проблемы с увеличением размера, так как увеличение массива является затратной операцией, проблемы при удалении большого количества элементов из-за необходимости сдвига элементов, и отсутствие потокобезопасности, что требует внешней синхронизации при использовании в многопоточной среде.'),
                    ('Что такое RecyclerView?', '', '["Мощный компонент пользовательского интерфейса, предназначенный для отображения динамических списков элементов", "Стандартный элемент управления для отображения статического текста", "Виджет для размещения отдельных кнопок на экране", "Инструмент для создания анимаций в приложении"]', '["Мощный компонент пользовательского интерфейса, предназначенный для отображения динамических списков элементов"]', 'ANDROID', 0, 0, 'RecyclerView — это мощный компонент пользовательского интерфейса в Android, который предназначен для отображения динамических списков элементов с возможностью эффективного управления большим количеством элементов и оптимизации их отображения.'),
                    ('Какие основные особенности у RecyclerView?', '', '["Использует концепцию view holders для эффективного повторного использования элементов списка при прокрутке", "Количество создаваемых объектов вью ограничивается только теми, которые видны пользователю", "Поддерживает различные компоновки (layouts), включая LinearLayoutManager, табличную (GridLayoutManager), и даже пользовательские компоновки благодаря LayoutManager API", "Предоставляет встроенную поддержку анимаций для операций добавления, удаления и перемещения элементов", "Не имеет встроенного метода для обработки нажатий на элементы"]', '["Использует концепцию view holders для эффективного повторного использования элементов списка при прокрутке", "Количество создаваемых объектов вью ограничивается только теми, которые видны пользователю", "Поддерживает различные компоновки (layouts), включая LinearLayoutManager, табличную (GridLayoutManager), и даже пользовательские компоновки благодаря LayoutManager API", "Предоставляет встроенную поддержку анимаций для операций добавления, удаления и перемещения элементов"]', 'ANDROID', 0, 0, 'RecyclerView использует концепцию view holders для эффективного повторного использования элементов списка при прокрутке, и количество создаваемых объектов вью ограничивается только теми, которые видны пользователю. Он поддерживает различные компоновки (layouts), включая LinearLayoutManager и GridLayoutManager, а также предоставляет встроенную поддержку анимаций для операций добавления, удаления и перемещения элементов. Однако он не имеет встроенного метода для обработки нажатий на элементы, что требует дополнительной реализации.'),
                    ('Какие ключевые компоненты имеет RecyclerView?', '', '["Adapter", "LayoutManager", "ViewHolder", "ItemDecoration", "ItemAnimator"]', '["Adapter", "LayoutManager", "ViewHolder"]', 'ANDROID', 0, 0, 'RecyclerView имеет три ключевых компонента: Adapter, который связывает данные с представлением; LayoutManager, который управляет расположением элементов на экране; и ViewHolder, который содержит ссылки на представления каждого элемента и управляет их повторным использованием.'),
                    ('За что отвечает Adapter в RecyclerView?', '', '["За связь данных с вьюхолдерами и создание вьюхолдеров", "За управление расположением элементов на экране", "За обработку пользовательских взаимодействий с элементами", "За отображение анимаций при изменении данных"]', '["За связь данных с вьюхолдерами и создание вьюхолдеров"]', 'ANDROID', 0, 0, 'Adapter в RecyclerView отвечает за связь данных с вьюхолдерами и за создание вьюхолдеров. Он предоставляет данные для отображения и создает объекты ViewHolder для каждого элемента списка.'),
                    ('За что отвечает LayoutManager в RecyclerView?', '', '["Управляет расположением элементов внутри RecyclerView, определяя его общий внешний вид", "Отвечает за создание и связывание данных с ViewHolder", "Обрабатывает нажатия и взаимодействия пользователя с элементами", "Управляет анимациями при изменении данных"]', '["Управляет расположением элементов внутри RecyclerView, определяя его общий внешний вид"]', 'ANDROID', 0, 0, 'LayoutManager в RecyclerView управляет расположением элементов внутри RecyclerView, определяя его общий внешний вид. Он отвечает за организацию элементов в виде списка, сетки или другой структуры, предоставляемой его реализацией.'),
                    ('За что отвечает ViewHolder в RecyclerView?', '', '["Содержит ссылки на все вью, которые необходимо заполнить данными в элементе списка", "Управляет расположением элементов внутри RecyclerView", "Создает и связывает данные с элементами", "Обрабатывает пользовательские взаимодействия с элементами"]', '["Содержит ссылки на все вью, которые необходимо заполнить данными в элементе списка"]', 'ANDROID', 0, 0, 'ViewHolder в RecyclerView содержит ссылки на все вью, которые необходимо заполнить данными в элементе списка, что упрощает доступ к ним и улучшает производительность за счет повторного использования.'),
                    ('В чем различие ListView и RecyclerView?', '', '["ListView менее эффективен при работе с большими списками", "ListView поддерживает различные макеты", "RecyclerView поддерживает различные макеты", "RecyclerView не поддерживает переиспользование элементов", "ListView создает каждый элемент списка и перерабатывает заново при прокрутке"]', '["ListView менее эффективен при работе с большими списками", "RecyclerView поддерживает различные макеты"]', 'ANDROID', 0, 0, 'ListView менее эффективен при работе с большими списками, так как создается новый элемент для каждого видимого элемента, что может привести к проблемам с производительностью. RecyclerView, напротив, поддерживает переиспользование элементов и различные макеты, обеспечивая большую гибкость и производительность.'),
                    ('Перечислите принципы SOLID:', '', '["Принцип единственной ответственности", "Принцип открытости/закрытости", "Принцип подстановки Барбары Лисков", "Принцип разделения интерфейса", "Принцип инверсии зависимостей", "Принцип единственной зависимости"]', '["Принцип единственной ответственности", "Принцип открытости/закрытости", "Принцип подстановки Барбары Лисков", "Принцип разделения интерфейса", "Принцип инверсии зависимостей"]', 'BASE', 0, 0, 'SOLID — это набор из пяти принципов объектно-ориентированного программирования, включающий: Принцип единственной ответственности, Принцип открытости/закрытости, Принцип подстановки Барбары Лисков, Принцип разделения интерфейса и Принцип инверсии зависимостей.'),
                    ('Что такое SOLID?', '', '["Пять основных принципов объектно-ориентированного программирования и проектирования, направленные на улучшение читаемости, масштабируемости и поддерживаемости кода", "Набор стандартов для написания кода на Java", "Инструменты для автоматизации тестирования", "Методология разработки программного обеспечения"]', '["Пять основных принципов объектно-ориентированного программирования и проектирования, направленные на улучшение читаемости, масштабируемости и поддерживаемости кода"]', 'BASE', 0, 0, 'SOLID — это пять основных принципов объектно-ориентированного программирования и проектирования, направленные на улучшение читаемости, масштабируемости и поддерживаемости кода, а также упрощение его тестирования и рефакторинга.'),
                    ('В чем заключается принцип единственной ответственности?', '', '["Каждый класс должен иметь только одну причину для изменения", "Каждый класс должен выполнять несколько задач одновременно", "Классы должны быть как можно более сложными", "Каждый класс должен иметь много методов для выполнения различных функций"]', '["Каждый класс должен иметь только одну причину для изменения"]', 'BASE', 0, 0, 'Принцип единственной ответственности утверждает, что каждый класс должен иметь только одну причину для изменения, что означает, что класс должен выполнять только одну задачу или функцию.'),
                    ('В чем заключается принцип открытости/закрытости?', '', '["Классы должны быть открыты для расширения, но закрыты для модификации", "Классы должны быть закрыты для расширения и модификации", "Классы должны быть изменяемыми и легко модифицируемыми", "Классы должны быть открыты для модификации, но закрыты для расширения"]', '["Классы должны быть открыты для расширения, но закрыты для модификации"]', 'BASE', 0, 0, 'Принцип открытости/закрытости гласит, что классы должны быть открыты для расширения, но закрыты для модификации. Это позволяет добавлять новые функциональности, не изменяя существующий код, что помогает предотвратить появление ошибок в уже проверенном коде.'),
                    ('В чем заключается принцип подстановки Барбары Лисков?', '', '["Объекты в программе можно заменять их наследниками без изменения свойств программы", "Наследники класса могут изменять поведение базового класса", "Наследники должны полностью заменить поведение базового класса", "Объекты не могут заменяться наследниками без изменения свойств программы"]', '["Объекты в программе можно заменять их наследниками без изменения свойств программы"]', 'BASE', 0, 0, 'Принцип подстановки Барбары Лисков гласит, что объекты в программе можно заменять их наследниками без изменения свойств программы. Наследник класса должен дополнять, а не заменять поведение базового класса.'),
                    ('В чем заключается принцип разделения интерфейса?', '', '["Клиенты не должны быть вынуждены зависеть от интерфейсов, которые они не используют", "Интерфейсы должны быть максимально универсальными, чтобы покрывать все возможные сценарии использования", "Каждый класс должен реализовывать все доступные интерфейсы", "Интерфейсы должны содержать как можно больше методов"]', '["Клиенты не должны быть вынуждены зависеть от интерфейсов, которые они не используют"]', 'BASE', 0, 0, 'Принцип разделения интерфейса гласит, что клиенты не должны быть вынуждены зависеть от интерфейсов, которые они не используют. Лучше иметь несколько специализированных интерфейсов, чем один универсальный, чтобы избежать ненужных зависимостей и улучшить гибкость системы.'),
                    ('В чем заключается принцип инверсии зависимостей?', '', '["Модули высокого уровня не должны зависеть от модулей низкого уровня. Оба типа модулей должны зависеть от абстракций", "Модули низкого уровня должны зависеть от модулей высокого уровня", "Абстракции должны зависеть от конкретных реализаций", "Модули высокого уровня и низкого уровня могут напрямую зависеть друг от друга"]', '["Модули высокого уровня не должны зависеть от модулей низкого уровня. Оба типа модулей должны зависеть от абстракций"]', 'BASE', 0, 0, 'Принцип инверсии зависимостей утверждает, что модули высокого уровня не должны зависеть от модулей низкого уровня. Оба типа модулей должны зависеть от абстракций. Абстракции не должны зависеть от деталей реализации. Это улучшает гибкость и возможности повторного использования кода, обеспечивая лучшее разделение обязанностей.'),
                    ('Как организовать взаимодействие Activity и фрагмента?', '', '["При помощи интерфейса: во фрагменте нужно определить интерфейс и реализовать его в активности, а затем в методе onAttach активити привести к интерфейсному типу и работать с ней", "Использовать прямые вызовы методов активности из фрагмента", "Через ViewModel", "Использовать глобальные переменные для передачи данных"]', '["При помощи интерфейса: во фрагменте нужно определить интерфейс и реализовать его в активности, а затем в методе onAttach активити привести к интерфейсному типу и работать с ней", "Через ViewModel"]', 'ANDROID', 0, 0, 'Взаимодействие между `Activity` и `Fragment` можно организовать через интерфейс, который определяет фрагмент и реализует активити. Также можно использовать `ViewModel`, чтобы передавать данные и управлять состоянием между `Activity` и `Fragment`.'),
                    ('Как передать параметры во фрагмент?', '', '["При помощи объекта Bundle и метода setArguments", "Используя глобальные переменные", "Передавая параметры напрямую через конструктор фрагмента", "Через ViewModel"]', '["При помощи объекта Bundle и метода setArguments", "Через ViewModel"]', 'ANDROID', 0, 0, 'Параметры можно передать во фрагмент с помощью объекта `Bundle`, который передается через метод `setArguments`. Также можно использовать `ViewModel` для управления данными и их передачи между фрагментами и активностями.'),
                    ('Что такое sealed класс?', '', '["Специальный тип класса, который используется для представления ограниченного набора подклассов", "Класс, который может быть наследован любым количеством подклассов", "Класс, который не может быть наследован", "Класс, который предоставляет интерфейс для расширения"]', '["Специальный тип класса, который используется для представления ограниченного набора подклассов"]', 'KOTLIN', 0, 0, 'Sealed класс в Kotlin используется для представления ограниченного набора подклассов, которые можно определить в одном файле. Это позволяет компилятору выполнять более строгую проверку и упрощает управление различными вариантами данных.'),
                    ('Зачем нужен sealed класс?', '', '["Ограничивает иерархию наследования, позволяя наследовать класс только внутри файла, в котором он объявлен", "Позволяет создавать произвольное количество подклассов без ограничений", "Используется для определения интерфейсов", "Позволяет использовать `when` выражение для обработки всех возможных вариантов"]', '["Ограничивает иерархию наследования, позволяя наследовать класс только внутри файла, в котором он объявлен", "Запечатанные классы идеально подходят для представления фиксированного набора состояний или вариантов, особенно в сочетании с `when` выражением", "Компилятор может проверять, обработаны ли все возможные случаи, что уменьшает вероятность ошибок", "Его использование повышает безопасность типов и помогает избежать ошибок во время выполнения, связанных с обработкой неожиданных типов"]', 'KOTLIN', 0, 0, 'Sealed класс в Kotlin ограничивает иерархию наследования, позволяя создавать подклассы только внутри того же файла, где он объявлен. Это полезно для представления фиксированного набора вариантов, упрощает использование `when` выражений и помогает предотвратить ошибки путем проверки всех возможных случаев компилятором.'),
                    ('Что такое чистая архитектура?', '', '["Подход к разработке программного обеспечения, который стремится обеспечить разделение ответственности между компонентами системы", "Модель разработки, ориентированная на работу только с базой данных", "Архитектурный стиль, который не допускает использование каких-либо зависимостей", "Концепция разработки, направленная на интеграцию всех слоев системы в один модуль"]', '["Подход к разработке программного обеспечения, который стремится обеспечить разделение ответственности между компонентами системы", "Упростить тестирование и поддержку, а также сделать архитектуру устойчивой к изменениям во внешних зависимостях и технологиях"]', 'BASE', 0, 0, 'Чистая архитектура — это подход к разработке программного обеспечения, который обеспечивает разделение ответственности между компонентами системы, упрощает тестирование и поддержку, а также делает архитектуру устойчивой к изменениям во внешних зависимостях и технологиях.'),
                    ('Какие утверждения верны о чистой архитектуре?', '', '["Архитектура не должна зависеть от библиотек или фреймворков, что позволяет использовать систему как набор инструментов, а не наоборот", "Бизнес-логика приложения должна быть изолирована от UI, баз данных и других внешних элементов, что облегчает тестирование", "Интерфейс пользователя должен быть легко изменяем без внесения изменений в остальную систему", "Бизнес-логика не должна зависеть от конкретной базы данных", "Бизнес-правила не должны зависеть от внешних служб или систем"]', '["Архитектура не должна зависеть от библиотек или фреймворков, что позволяет использовать систему как набор инструментов, а не наоборот", "Бизнес-логика приложения должна быть изолирована от UI, баз данных и других внешних элементов, что облегчает тестирование", "Интерфейс пользователя должен быть легко изменяем без внесения изменений в остальную систему", "Бизнес-логика не должна зависеть от конкретной базы данных", "Бизнес-правила не должны зависеть от внешних служб или систем"]', 'BASE', 0, 0, 'Чистая архитектура предполагает, что архитектура не должна зависеть от библиотек или фреймворков, бизнес-логика приложения должна быть изолирована от UI, баз данных и других внешних элементов, интерфейс пользователя должен быть легко изменяем без внесения изменений в остальную систему, бизнес-логика не должна зависеть от конкретной базы данных, и бизнес-правила не должны зависеть от внешних служб или систем.'),
                    ('На какие слои делится чистая архитектура?', '', '["Data", "Domain", "Presentation", "Service", "Utility"]', '["Data", "Domain", "Presentation"]', 'BASE', 0, 0, 'Чистая архитектура делится на слои Data, Domain и Presentation. Каждый слой имеет свою ответственность: Data отвечает за работу с данными, Domain содержит бизнес-логику, а Presentation отвечает за пользовательский интерфейс.'),
                    ('За что отвечает data слой?', '', '["За работу с данными", "За обработку бизнес-логики", "За взаимодействие с пользовательским интерфейсом", "За управление состоянием приложения"]', '["За работу с данными"]', 'BASE', 0, 0, 'Data слой отвечает за работу с данными, включая взаимодействие с базами данных, сетевыми запросами и другими источниками данных. Он содержит интерфейсы репозитория и источников данных.'),
                    ('Что содержится в domain слое?', '', '["Модели и бизнес-логика (entities, use cases)", "Реализация пользовательского интерфейса", "Интерфейсы репозитория и источников данных", "Код, связанный с сетевыми запросами"]', '["Модели и бизнес-логика (entities, use cases)"]', 'BASE', 0, 0, 'Domain слой содержит модели и бизнес-логику, включая сущности (entities) и случаи использования (use cases). Это слой, который реализует бизнес-правила и логику приложения.'),
                    ('Что содержит presentation слой?', '', '["Классы, которые отображают данные (Fragment/ViewModel)", "Модели и бизнес-логика (entities, use cases)", "Интерфейсы репозитория и источников данных", "Код для работы с базой данных"]', '["Классы, которые отображают данные (Fragment/ViewModel)"]', 'BASE', 0, 0, 'Presentation слой содержит классы, которые отвечают за отображение данных пользователю и управление пользовательским интерфейсом, такие как Fragments и ViewModels.'),
                    ('Какие особенности использования object?', '', '["Создание синглтонов", "Создание объектов без класса (анонимных объектов)", "Реализация объектов-компаньонов", "Объявление обычных классов с несколькими экземплярами"]', '["Создание синглтонов", "Создание объектов без класса (анонимных объектов)", "Реализация объектов-компаньонов"]', 'KOTLIN', 0, 0, 'Ключевые особенности использования ключевого слова `object` в Kotlin включают создание синглтонов, создание объектов без явного класса (анонимные объекты) и реализацию объектов-компаньонов для классов.'),
                    ('Как создать синглтон?', '', '["Использовать ключевое слово `object`", "Создать обычный класс и контролировать его единственный экземпляр вручную", "Использовать аннотацию `@Singleton`", "Использовать фабричный метод с приватным конструктором"]', '["Использовать ключевое слово `object`"]', 'KOTLIN', 0, 0, 'Для создания синглтона в Kotlin используется ключевое слово `object`, которое создаёт класс с единственным экземпляром, доступным во всей программе. Это упрощает реализацию паттерна синглтон по сравнению с обычными классами и ручным контролем экземпляров.'),
                    ('Что такое объекты-компаньоны (`companion object`)?', '', '["Объекты, которые позволяют объявлять методы и свойства, доступные на уровне класса, без необходимости создания экземпляра класса", "Объекты, которые создаются при каждом создании экземпляра класса", "Специальные объекты для создания синглтонов", "Объекты, которые хранят состояние экземпляра класса"]', '["Объекты, которые позволяют объявлять методы и свойства, доступные на уровне класса, без необходимости создания экземпляра класса"]', 'KOTLIN', 0, 0, 'Объекты-компаньоны (`companion object`) в Kotlin позволяют объявлять методы и свойства, которые можно вызывать на уровне класса, без необходимости создания экземпляра класса. Они полезны для хранения статических методов и свойств, которые должны быть доступны для использования во всей программе.'),
                    ('Для чего нужны анонимные классы?', '', '["Для реализации интерфейса или абстрактного класса без создания явного класса", "Для создания синглтонов", "Для объявления методов на уровне класса", "Для управления доступом к приватным членам класса"]', '["Для реализации интерфейса или абстрактного класса без создания явного класса"]', 'JAVA', 0, 0, 'Анонимные классы позволяют реализовать интерфейс или абстрактный класс прямо в месте его использования, без необходимости создания отдельного явного класса. Это удобно для кратковременных, одноразовых реализаций, таких как обработчики событий или лямбда-выражения.'),
                    ('Какие особенности у ключевого слова object?', '', '["Объекты, объявленные через `object`, инициализируются лениво при первом обращении к ним", "Объекты, объявленные через `object` могут наследовать другие классы и реализовывать интерфейсы", "В контексте объектов-компаньонов `object` позволяет дополнительно расширять функционал класса без необходимости наследования или паттерна `Decorator`", "Объекты, объявленные через `object`, всегда создаются сразу при загрузке класса"]', '["Объекты, объявленные через `object`, инициализируются лениво при первом обращении к ним", "Объекты, объявленные через `object` могут наследовать другие классы и реализовывать интерфейсы", "В контексте объектов-компаньонов `object` позволяет дополнительно расширять функционал класса без необходимости наследования или паттерна `Decorator`"]', 'KOTLIN', 0, 0, 'Ключевое слово `object` в Kotlin используется для создания синглтонов, лениво инициализируемых объектов и объектов-компаньонов. Объекты `object` инициализируются при первом обращении к ним и могут реализовывать интерфейсы или наследовать другие классы. Также в случае объектов-компаньонов оно позволяет расширять функционал класса, не создавая дополнительных наследников или применяя паттерн "Decorator".'),
                    ('Для чего используется Activity?', '', '["Для предоставления макета (layout), который будет содержать все элементы пользовательского интерфейса, такие как кнопки, текстовые поля, изображения и прочее, с которыми пользователь может взаимодействовать", "Служит в качестве `лица` приложения для взаимодействия с пользователем, обрабатывая пользовательские входные данные, такие как нажатие кнопок, ввод текста", "Для управления жизненным циклом приложения", "Для управления доступом к базе данных приложения"]', '["Для предоставления макета (layout), который будет содержать все элементы пользовательского интерфейса, такие как кнопки, текстовые поля, изображения и прочее, с которыми пользователь может взаимодействовать", "Служит в качестве `лица` приложения для взаимодействия с пользователем, обрабатывая пользовательские входные данные, такие как нажатие кнопок, ввод текста"]', 'ANDROID', 0, 0, 'Activity в Android представляет собой компонент пользовательского интерфейса, который предоставляет макет для отображения элементов пользовательского интерфейса и служит "лицом" приложения для взаимодействия с пользователем. Она обрабатывает пользовательские входные данные, такие как нажатия кнопок и ввод текста, и управляет жизненным циклом экрана приложения.'),
                    ('В каком потоке запускается самый обычный сервис?', '', '["В главном потоке приложения", "В фоновом потоке", "В отдельном потоке, созданном системой", "В пользовательском потоке"]', '["В главном потоке приложения"]', 'ANDROID', 0, 0, 'Самый обычный сервис в Android запускается в главном потоке приложения. Это означает, что он выполняется в том же потоке, что и пользовательский интерфейс, и может блокировать UI, если выполняет длительные операции.'),
                    ('В чем может быть проблема, что обычный сервис запускается в главном потоке?', '', '["Длительные операции могут привести к зависанию пользовательского интерфейса", "Проблем с производительностью не возникает", "Сервис не может выполнять длительные операции", "Операции выполняются параллельно с UI-потоком"]', '["Длительные операции могут привести к зависанию пользовательского интерфейса"]', 'ANDROID', 0, 0, 'Если в сервисе выполняются длительные или ресурсоемкие операции, это может привести к зависанию пользовательского интерфейса и сообщениям о том, что приложение не отвечает. Это происходит потому, что сервис выполняется в главном потоке, что блокирует его выполнение и может влиять на производительность всего приложения.'),
                    ('Как решить проблемы с зависанием UI при работе с сервисами?', '', '["Использовать отдельные потоки", "Использовать AsyncTask", "Использовать Kotlin Coroutines", "Ограничить количество выполняемых операций в сервисе", "Разделить сервис на несколько компонентов, работающих параллельно"]', '["Использовать отдельные потоки", "Использовать AsyncTask", "Использовать Kotlin Coroutines"]', 'ANDROID', 0, 0, 'Для предотвращения зависания пользовательского интерфейса при работе с сервисами необходимо выполнять длительные или ресурсоемкие операции в фоновом режиме. Это можно сделать с помощью отдельных потоков, AsyncTask или Kotlin Coroutines, которые позволяют эффективно управлять задачами и поддерживать отзывчивость интерфейса.'),
                    ('Какой сервис запускается в отдельном потоке?', '', '["IntentService", "Bound Service", "Foreground Service", "JobScheduler Service", "Local Service"]', '["IntentService"]', 'ANDROID', 0, 0, 'IntentService — это специализированный сервис, который обрабатывает все входящие намерения (intents) в отдельном фоновом потоке, обеспечивая тем самым отсутствие блокировки основного пользовательского интерфейса во время выполнения долгих операций.'),
                    ('Какие существуют виды сервисов?', '', '["Service", "ForegroundService", "IntentService", "JobService", "JobIntentService", "BoundService", "BackgroundService", "WorkerService"]', '["Service", "ForegroundService", "IntentService", "JobService", "JobIntentService"]', 'ANDROID', 0, 0, 'В Android существует несколько видов сервисов, которые используются для выполнения различных задач в фоновом режиме, включая обычные сервисы, ForegroundService для выполнения задач с повышенным приоритетом, IntentService для работы в отдельном потоке, а также JobService и JobIntentService для выполнения задач, запланированных на будущее.'),
                    ('Какие сервисы предпочтительнее использовать вместо IntentService из-за ограничений на фоновую работу, начиная с Android 8.0?', '', '["JobIntentService", "WorkManager", "ForegroundService", "BackgroundService", "JobService", "BoundService"]', '["JobIntentService", "WorkManager"]', 'ANDROID', 0, 0, 'С начала Android 8.0 (API 26), из-за ограничений на фоновую работу, рекомендуется использовать JobIntentService и WorkManager вместо IntentService для выполнения фоновых задач.'),
                    ('Какой жизненный цикл у сервисов?', '', '["onCreate, onStartCommand, onDestroy", "onStart, onResume, onPause", "onAttach, onCreate, onDestroy", "onCreate, onRestart, onDestroy"]', '["onCreate, onStartCommand, onDestroy"]', 'ANDROID', 0, 0, 'Жизненный цикл сервиса включает три основных метода: `onCreate`, который вызывается при создании сервиса, `onStartCommand`, который вызывается при запуске команды для сервиса, и `onDestroy`, который вызывается при остановке и уничтожении сервиса.'),
                    ('Какой метод нужно переопределить у IntentService вместо onStartCommand?', '', '["onHandleIntent", "onCreate", "onDestroy", "onBind"]', '["onHandleIntent"]', 'ANDROID', 0, 0, 'Для работы с `IntentService` вместо метода `onStartCommand` необходимо переопределить метод `onHandleIntent`, который выполняется в фоновом потоке и обрабатывает входящие `Intent` запросы.'),
                    ('Как выполняются несколько задач, полученных одновременно в Service?', '', '["Все сразу начинают выполняться", "Они выполняются по очереди в одном потоке", "Они ставятся в очередь и выполняются последовательно", "Только первая задача начинает выполняться, остальные игнорируются"]', '["Все сразу начинают выполняться"]', 'ANDROID', 0, 0, 'В стандартном `Service`, когда несколько задач получены одновременно, они все сразу начинают выполняться в основном потоке, что может привести к перегрузке и задержкам в работе интерфейса.'),
                    ('Как выполняются несколько задач, полученных одновременно в IntentService?', '', '["Они ставятся в очередь и выполняются последовательно", "Все сразу начинают выполняться", "Только первая задача начинает выполняться, остальные игнорируются", "Они выполняются параллельно в отдельных потоках"]', '["Они ставятся в очередь и выполняются последовательно"]', 'ANDROID', 0, 0, 'В `IntentService` все полученные задачи ставятся в очередь и выполняются поочередно в отдельном фоновом потоке, что предотвращает перегрузку основного потока и гарантирует, что задачи будут выполнены последовательно.'),
                    ('Для чего нужен ForegroundService?', '', '["Это тип сервиса, который должен отображать уведомление для пользователя, чтобы он был в курсе выполняемой задачи", "Это сервис, который работает только при активном приложении", "Это сервис, который запускается только для выполнения коротких задач", "Это сервис, который автоматически завершает работу после выполнения задачи"]', '["Это тип сервиса, который должен отображать уведомление для пользователя, чтобы он был в курсе выполняемой задачи"]', 'ANDROID', 0, 0, 'ForegroundService используется для выполнения задач, которые должны быть явно видны пользователю через уведомление, особенно если эти задачи продолжаются даже после закрытия приложения.'),
                    ('Для чего используется ForegroundService?', '', '["Обычно используется для длительных операций, таких как воспроизведение музыки, запись аудио, использование GPS", "Обычно используется для выполнения коротких задач и не требует уведомления", "Обычно используется для задач, которые могут быть выполнены только при активном пользовательском интерфейсе", "Обычно используется для тестирования функций приложения"]', '["Обычно используется для длительных операций, таких как воспроизведение музыки, запись аудио, использование GPS"]', 'ANDROID', 0, 0, 'ForegroundService обычно используется для выполнения длительных задач, которые требуют постоянного внимания пользователя и отображения уведомления о текущей активности.'),
                    ('Какие особенности у ForegroundService?', '', '["Пользователь видит уведомление в статусной строке, пока ForegroundService активен", "Остается активным, даже если система испытывает нехватку ресурсов", "Может быть остановлен системой в случае нехватки ресурсов", "Не требует уведомления для пользователя"]', '["Пользователь видит уведомление в статусной строке, пока ForegroundService активен", "Остается активным, даже если система испытывает нехватку ресурсов"]', 'ANDROID', 0, 0, 'ForegroundService имеет несколько ключевых особенностей: он отображает уведомление в статусной строке, пока активен, и остается активным даже в условиях нехватки ресурсов, обеспечивая таким образом непрерывность выполнения задач.'),
                    ('Какие особенности у IntentService?', '', '["Работает в отдельном фоновом потоке", "Прекращает работу самостоятельно после выполнения всех задач", "Упрощает выполнение фоновых задач, не требуя ручного управления потоками", "Не поддерживает обработку нескольких задач одновременно"]', '["Работает в отдельном фоновом потоке", "Прекращает работу самостоятельно после выполнения всех задач", "Упрощает выполнение фоновых задач, не требуя ручного управления потоками"]', 'ANDROID', 0, 0, 'IntentService обладает следующими особенностями: он работает в отдельном фоновом потоке, автоматически прекращает свою работу после выполнения всех задач, и упрощает выполнение фоновых задач, не требуя ручного управления потоками.'),
                    ('Для чего нужен JobService?', '', '["Для выполнения задач, которые могут быть отложены и выполнены системой в оптимальный момент (например, когда устройство подключено к сети или заряжается)", "Для выполнения задач в главном потоке приложения", "Для немедленного выполнения задач в фоновом потоке", "Для управления пользовательскими интерфейсами и их обновлением"]', '["Для выполнения задач, которые могут быть отложены и выполнены системой в оптимальный момент (например, когда устройство подключено к сети или заряжается)"]', 'ANDROID', 0, 0, 'JobService используется для выполнения задач, которые могут быть отложены и выполнены системой в оптимальный момент, например, когда устройство подключено к сети или заряжается.'),
                    ('Как работает JobService?', '', '["Сервис планируется с помощью JobScheduler и подходит для задач, не требующих немедленного выполнения", "Сервис запускается немедленно в основном потоке", "Задачи выполняются параллельно с другими задачами в главном потоке", "Сервис автоматически прекращает работу после выполнения одной задачи"]', '["Сервис планируется с помощью JobScheduler и подходит для задач, не требующих немедленного выполнения"]', 'ANDROID', 0, 0, 'JobService работает в связке с JobScheduler, который планирует выполнение задач, подходящих для выполнения в оптимальное время, например, когда устройство подключено к сети или находится на зарядке. Задачи не требуют немедленного выполнения и могут быть отложены.'),
                    ('Какие особенности JobService?', '', '["Подходит для выполнения задач, которые можно выполнить позже", "Позволяет задавать условия для выполнения задачи (например, подключение к сети, зарядка устройства)", "Оптимизирован для энергосбережения", "Требует немедленного выполнения задач", "Не поддерживает отложенное выполнение задач"]', '["Подходит для выполнения задач, которые можно выполнить позже", "Позволяет задавать условия для выполнения задачи (например, подключение к сети, зарядка устройства)", "Оптимизирован для энергосбережения"]', 'ANDROID', 0, 0, 'JobService позволяет планировать задачи, которые можно выполнять позже в соответствии с определенными условиями, такими как подключение к сети или зарядка устройства, и оптимизирован для энергосбережения, чтобы минимизировать потребление ресурсов устройства.'),
                    ('Для чего нужен JobIntentService?', '', '["Сочетает функции IntentService и JobService", "Обеспечивает поддержку отложенного выполнения задач на более старых версиях Android (до Android 8.0)", "Подходит для задач, которые должны быть выполнены асинхронно и могут быть отложены", "Поддерживает только мгновенное выполнение задач", "Работает только на фоне и не поддерживает работу в переднем плане"]', '["Сочетает функции IntentService и JobService", "Обеспечивает поддержку отложенного выполнения задач на более старых версиях Android (до Android 8.0)", "Подходит для задач, которые должны быть выполнены асинхронно и могут быть отложены"]', 'ANDROID', 0, 0, 'JobIntentService объединяет возможности IntentService и JobService, позволяя выполнять асинхронные задачи, которые могут быть отложены, и обеспечивает поддержку для более старых версий Android, где нет встроенной поддержки для таких задач.'),
                    ('Какие особенности у JobIntentService?', '', '["Работает как IntentService на старых версиях Android", "На новых версиях использует JobScheduler для планирования задач", "Позволяет выполнять задачи только в переднем плане", "Не поддерживает выполнение задач асинхронно", "Не имеет возможности планировать задачи на основе условий"]', '["Работает как IntentService на старых версиях Android", "На новых версиях использует JobScheduler для планирования задач"]', 'ANDROID', 0, 0, 'JobIntentService позволяет выполнять задачи асинхронно, используя IntentService на старых версиях Android и переходя на использование JobScheduler для планирования задач на новых версиях.'),
                    ('Для чего нужен AlarmManager?', '', '["Используется для выполнения задач в определённое время или через определённые интервалы времени", "Подходит для задач, которые должны быть выполнены даже при спящем устройстве", "Используется только для работы в переднем плане", "Не поддерживает периодические задачи", "Подходит только для задач, связанных с пользовательским интерфейсом"]', '["Используется для выполнения задач в определённое время или через определённые интервалы времени", "Подходит для задач, которые должны быть выполнены даже при спящем устройстве"]', 'ANDROID', 0, 0, 'AlarmManager используется для выполнения задач в заданное время или через интервалы времени, и поддерживает выполнение задач даже при спящем устройстве, что делает его полезным для периодических уведомлений и синхронизации данных.'),
                    ('Какие особенности AlarmManager?', '', '["Может пробудить устройство для выполнения задачи", "Поддерживает как одноразовые, так и периодические задачи", "Менее эффективен для частых задач, так как может привести к чрезмерному расходу батареи", "Всегда выполняется в главном потоке", "Не поддерживает выполнение задач при спящем режиме устройства"]', '["Может пробудить устройство для выполнения задачи", "Поддерживает как одноразовые, так и периодические задачи", "Менее эффективен для частых задач, так как может привести к чрезмерному расходу батареи"]', 'ANDROID', 0, 0, 'AlarmManager может пробудить устройство для выполнения задачи и поддерживает как одноразовые, так и периодические задачи. Однако, его использование для частых задач может привести к чрезмерному расходу батареи.'),
                    ('Для чего нужен WorkManager?', '', '["Для выполнения отложенных задач, которые могут продолжаться после закрытия приложения или перезапуска устройства", "Для выполнения задач, требующих немедленного выполнения", "Для работы с фоновыми задачами с высокой частотой выполнения", "Для задач, которые не могут быть гарантированно выполнены", "Для выполнения задач только в главном потоке"]', '["Для выполнения отложенных задач, которые могут продолжаться после закрытия приложения или перезапуска устройства"]', 'ANDROID', 0, 0, 'WorkManager предназначен для выполнения отложенных задач, которые могут продолжаться после закрытия приложения или перезапуска устройства. Он подходит для задач, которые должны быть гарантированно выполнены, такие как загрузка данных, резервное копирование и синхронизация.'),
                    ('Какие особенности WorkManager?', '', '["Работает в зависимости от условий (состояние сети, зарядка, и т.д.)", "Поддерживает цепочки задач и выполнение с отсрочкой", "Автоматически выбирает наиболее подходящий способ выполнения задачи (например, JobScheduler, AlarmManager)", "Не поддерживает выполнение задач при закрытом приложении", "Не может выполнять задачи при перезагрузке устройства"]', '["Работает в зависимости от условий (состояние сети, зарядка, и т.д.)", "Поддерживает цепочки задач и выполнение с отсрочкой", "Автоматически выбирает наиболее подходящий способ выполнения задачи (например, JobScheduler, AlarmManager)"]', 'ANDROID', 0, 0, 'WorkManager поддерживает выполнение задач в зависимости от условий, таких как состояние сети или зарядка устройства, а также позволяет создавать цепочки задач и отсроченные задачи. Он автоматически выбирает наиболее подходящий способ выполнения задачи, будь то JobScheduler, AlarmManager или другой механизм.'),
                    ('Для чего нужны Extension функции?', '', '["Позволяют добавлять новую функциональность к существующим классам без их модификации или наследования", "Позволяют изменять поведение стандартных библиотек языка", "Упрощают процесс создания классов и объектов", "Обеспечивают автоматическое управление памятью", "Ускоряют компиляцию кода"]', '["Позволяют добавлять новую функциональность к существующим классам без их модификации или наследования"]', 'KOTLIN', 0, 0, 'Extension функции в Kotlin позволяют расширять существующие классы новыми методами и свойствами без необходимости изменять сам класс или создавать его наследников.'),
                    ('Какие преимущества использования Extension функций и свойств?', '', '["Улучшение читаемости кода", "Функциональность можно добавлять к классам без изменения исходного кода класса или создания подклассов", "Расширения дают возможность расширять функциональность классов из внешних библиотек или фреймворков, к исходному коду которых у вас нет доступа", "Ускорение работы приложения за счет оптимизации внутренней логики", "Обеспечивают автоматическое управление памятью"]', '["Улучшение читаемости кода", "Функциональность можно добавлять к классам без изменения исходного кода класса или создания подклассов", "Расширения дают возможность расширять функциональность классов из внешних библиотек или фреймворков, к исходному коду которых у вас нет доступа"]', 'KOTLIN', 0, 0, 'Преимущества использования Extension функций и свойств включают улучшение читаемости кода, возможность добавления функциональности к классам без изменения их исходного кода или создания подклассов, а также расширение функциональности классов из внешних библиотек или фреймворков, к исходному коду которых нет доступа.'),
                    ('Какие жизненные циклы View?', '', '["onMeasure()", "onLayout()", "onDraw()", "onCreate()", "onPause()"]', '["onMeasure()", "onLayout()", "onDraw()"]', 'ANDROID', 0, 0, 'Жизненные циклы View включают методы onMeasure() для измерения размеров View, onLayout() для определения размещения View в родительском контейнере и onDraw() для отрисовки содержимого View.'),
                    ('Для чего нужен метод onMeasure?', '', '["Установить сколько в пикселях будет занимать view", "Определить, как View будет размещаться в родительском контейнере", "Отрисовать содержимое View", "Определить, когда View будет отображаться на экране"]', '["Установить сколько в пикселях будет занимать view"]', 'ANDROID', 0, 0, 'Метод onMeasure() используется для определения размеров View, то есть, сколько в пикселях View будет занимать место на экране.'),
                    ('Для чего нужен метод onLayout?', '', '["Для определения размещения View в родительском контейнере", "Для установки размеров View", "Для отрисовки содержимого View", "Для определения видимости View на экране"]', '["Для определения размещения View в родительском контейнере"]', 'ANDROID', 0, 0, 'Метод onLayout() используется для определения точного размещения View внутри родительского контейнера, основываясь на размерах, определённых в методе onMeasure().'),
                    ('Для чего нужен метод onDraw?', '', '["Для отрисовки содержимого View", "Для установки размеров View", "Для определения размещения View в родительском контейнере", "Для определения видимости View на экране"]', '["Для отрисовки содержимого View"]', 'ANDROID', 0, 0, 'Метод onDraw() используется для отрисовки содержимого View, включая графические элементы и текст, используя Canvas, который предоставляется в качестве параметра.'),
                    ('Что такое interface?', '', '["Структура, которая определяет набор абстрактных методов, которые должен реализовать класс, объявляющий, что он реализует этот интерфейс", "Класс, который предоставляет конкретные реализации методов", "Механизм для создания экземпляров объектов", "Тип данных для хранения примитивных значений"]', '["Структура, которая определяет набор абстрактных методов, которые должен реализовать класс, объявляющий, что он реализует этот интерфейс"]', 'BASE', 0, 0, 'Интерфейс (interface) представляет собой структуру, которая определяет набор абстрактных методов, которые должен реализовать класс. Интерфейсы позволяют создавать гибкие и масштабируемые системы, где классы могут реализовывать несколько интерфейсов и предоставлять свою собственную реализацию методов, объявленных в интерфейсе.'),
                    ('Какие особенности у интерфейсов?', '', '["Интерфейсы не могут содержать реализацию методов (за исключением default и static методов, доступных начиная с Java 8), и все методы в интерфейсе по умолчанию являются public и abstract", "Интерфейсы также могут содержать константы", "Класс может реализовать множество интерфейсов, что позволяет использовать множественное наследование", "Интерфейсы могут содержать конструкторы"]', '["Интерфейсы не могут содержать реализацию методов (за исключением default и static методов, доступных начиная с Java 8), и все методы в интерфейсе по умолчанию являются public и abstract", "Интерфейсы также могут содержать константы", "Класс может реализовать множество интерфейсов, что позволяет использовать множественное наследование"]', 'BASE', 0, 0, 'Интерфейсы не могут содержать реализацию методов (кроме методов с модификаторами default и static, добавленных в Java 8). Все методы в интерфейсе по умолчанию являются `public` и `abstract`. Интерфейсы могут содержать константы и классы могут реализовывать несколько интерфейсов, что обеспечивает поддержку множественного наследования. Интерфейсы не могут содержать конструкторы.'),
                    ('Что такое абстрактный класс?', '', '["Класс, который не может быть инстанцирован сам по себе и может содержать как абстрактные методы (без реализации), так и методы с реализацией", "Класс, который может содержать только абстрактные методы", "Класс, который можно инстанцировать, но не может содержать методы с реализацией", "Класс, предназначенный только для реализации интерфейсов"]', '["Класс, который не может быть инстанцирован сам по себе и может содержать как абстрактные методы (без реализации), так и методы с реализацией"]', 'BASE', 0, 0, 'Абстрактный класс не может быть инстанцирован сам по себе и может содержать как абстрактные методы (без реализации), так и методы с реализацией. Он может также иметь состояние (поля данных), конструкторы и деструкторы. Абстрактный класс служит в качестве базового класса для других классов, которые должны реализовать его абстрактные методы.'),
                    ('Какие особенности абстрактного класса?', '', '["Класс может наследовать только один абстрактный класс, так как абстрактные классы не поддерживают множественное наследование классов", "Может содержать только абстрактные методы", "Может содержать полную реализацию методов, а также абстрактные методы", "Не может содержать поля или конструкторы"]', '["Класс может наследовать только один абстрактный класс, так как абстрактные классы не поддерживают множественное наследование классов", "Может содержать полную реализацию методов, а также абстрактные методы", "Может содержать поля, которые могут иметь различные уровни доступа и не обязательно быть константами", "Может содержать конструкторы, что позволяет выполнять инициализацию класса перед использованием"]', 'BASE', 0, 0, 'Абстрактный класс может содержать полную реализацию методов, а также абстрактные методы. Он может иметь поля с различными уровнями доступа, а также конструкторы для инициализации класса. Поскольку абстрактные классы не поддерживают множественное наследование, класс может наследовать только один абстрактный класс.'),
                    ('Какие структуры данных существуют?', '', '["Array", "List", "Stack", "Queue", "Deque", "Hash Table", "Tree", "Binary Tree", "Red-Black Tree", "Graph", "Heap", "Set"]', '["Array", "List", "Stack", "Queue", "Deque", "Hash Table", "Tree", "Binary Tree", "Red-Black Tree", "Graph", "Heap"]', 'BASE', 0, 0, 'Существуют различные структуры данных, включая массивы, списки, стеки, очереди, двусторонние очереди (Deque), хеш-таблицы, деревья (например, бинарные деревья и красно-чёрные деревья), графы и кучи. Каждая структура данных имеет свои особенности и применяется в различных сценариях для эффективного хранения и обработки данных.'),
                    ('Что означает в Android-разработке подход Single Activity?', '', '["Вся пользовательская интеракция происходит в одной Activity, а различные экраны реализуются с помощью Fragment", "Каждый экран приложения реализуется в отдельной Activity", "Подход, при котором используется только один фрагмент для всего пользовательского интерфейса", "Традиционный подход, в котором каждый экран имеет свою собственную Activity"]', '["Вся пользовательская интеракция происходит в одной Activity, а различные экраны реализуются с помощью Fragment"]', 'ANDROID', 0, 0, 'В подходе Single Activity вся пользовательская интеракция с приложением происходит в рамках одной Activity, а различные экраны реализуются с помощью Fragment. Это упрощает навигацию и управление состоянием, так как все экраны представлены фрагментами внутри одной Activity.'),
                    ('Зачем нужен метод equals?', '', '["Определяет, равен ли текущий объект другому объекту", "Определяет, равен ли текущий объект другому объекту по ссылке в памяти", "Переопределение метода позволяет сравнивать объекты по содержимому", "Метод equals используется для сравнения объектов по их типам"]', '["Определяет, равен ли текущий объект другому объекту", "Переопределение метода позволяет сравнивать объекты по содержимому"]', 'JAVA', 0, 0, 'Метод `equals()` используется для определения равенства текущего объекта с другим объектом. По умолчанию он сравнивает ссылки на объекты, но часто его нужно переопределять, чтобы сравнивать объекты по содержимому, отражая логику равенства для конкретного класса.'),
                    ('Зачем нужен метод hashCode?', '', '["Возвращает хеш-код объекта, который используется хеш-таблицами для определения места хранения объекта", "Определяет равенство объектов по содержимому", "Метод hashCode используется для сравнения объектов по ссылке в памяти", "Метод hashCode возвращает строковое представление объекта"]', '["Возвращает хеш-код объекта, который используется хеш-таблицами для определения места хранения объекта"]', 'JAVA', 0, 0, 'Метод `hashCode()` возвращает хеш-код объекта, используемый хеш-таблицами для определения места хранения объекта. В Java хеш-код представляет собой целочисленное значение, связанное с содержимым объекта. Согласно контракту Java, если два объекта равны согласно методу `equals()`, их хеш-коды также должны быть равны, что необходимо для корректной работы объектов в качестве ключей в хеш-таблицах.'),
                    ('В чем отличие между Job и SupervisorJob?', '', '["В `Job` исключение в любой из дочерних корутин приводит к отмене всей иерархии задач, а в `SupervisorJob` исключения изолированы в пределах корутины, в которой они произошли", "`Job` подходит для задач, где необходимо, чтобы все дочерние корутины были отменены при возникновении ошибки в любой из них", "`SupervisorJob` используется, когда задачи независимы друг от друга, и необходимо, чтобы ошибка в одной из них не влияла на остальные", "`SupervisorJob` часто применяется в UI-приложениях, где различные операции, такие как загрузка данных или анимации, должны быть независимыми, и сбой в одной операции не должен прерывать всю работу приложения"]', '["В `Job` исключение в любой из дочерних корутин приводит к отмене всей иерархии задач, а в `SupervisorJob` исключения изолированы в пределах корутины, в которой они произошли", "`SupervisorJob` используется, когда задачи независимы друг от друга, и необходимо, чтобы ошибка в одной из них не влияла на остальные"]', 'KOTLIN', 0, 0, 'В `Job` исключение в любой из дочерних корутин приводит к отмене всей иерархии задач, а в `SupervisorJob` исключения изолированы в пределах корутины, в которой они произошли, позволяя другим корутинам продолжать свое выполнение. `Job` подходит для задач, где необходимо, чтобы все дочерние корутины были отменены при возникновении ошибки в любой из них. `SupervisorJob` используется, когда задачи независимы друг от друга, и необходимо, чтобы ошибка в одной из них не влияла на остальные. `SupervisorJob` часто применяется в UI-приложениях, где различные операции, такие как загрузка данных или анимации, должны быть независимыми, и сбой в одной операции не должен прерывать всю работу приложения.'),
                    ('Что из себя представляет библиотека Room?', '', '["Библиотека управления базами данных, которая служит абстрактным слоем над SQLite для удобного доступа к базе данных", "Инструмент для работы с файловой системой Android", "Библиотека для работы с сетевыми запросами", "API для работы с пользовательским интерфейсом"]', '["Библиотека управления базами данных, которая служит абстрактным слоем над SQLite для удобного доступа к базе данных"]', 'ANDROID', 0, 0, 'Библиотека Room представляет собой абстрактный слой над SQLite, который упрощает доступ и управление базой данных, обеспечивая удобный способ работы с данными и интеграцию с компонентами архитектуры Android.'),
                    ('Основные возможности библиотеки Room?', '', '["Использует аннотации для проверки SQL-запросов на этапе компиляции, что помогает избежать ошибок во время выполнения, связанных с базой данных", "Может легко возвращать данные в виде LiveData или Flowable объектов, обеспечивая реактивное взаимодействие с UI", "Обеспечивает проверку SQL-запросов во время компиляции, позволяя заранее обнаруживать потенциальные ошибки до запуска приложения на устройстве", "Поддерживает только синхронные запросы и не позволяет работать с асинхронными операциями"]', '["Использует аннотации для проверки SQL-запросов на этапе компиляции, что помогает избежать ошибок во время выполнения, связанных с базой данных", "Может легко возвращать данные в виде LiveData или Flowable объектов, обеспечивая реактивное взаимодействие с UI", "Обеспечивает проверку SQL-запросов во время компиляции, позволяя заранее обнаруживать потенциальные ошибки до запуска приложения на устройстве"]', 'ANDROID', 0, 0, 'Библиотека Room предоставляет возможность проверки SQL-запросов на этапе компиляции, возвращает данные в виде LiveData или Flowable для реактивного взаимодействия и обеспечивает безопасность и удобство работы с базой данных.'),
                    ('Основные компоненты библиотеки Room?', '', '["Database", "Entity", "DAO", "Fragment"]', '["Database", "Entity", "DAO"]', 'ANDROID', 0, 0, 'Основные компоненты библиотеки Room включают Database (определяет базу данных и включает DAO и Entity), Entity (определяет таблицы базы данных), и DAO (определяет методы доступа к данным).'),
                    ('За что отвечает Database в библиотеке Room?', '', '["Определяет список сущностей (таблиц базы данных) и версию базы данных", "Обрабатывает SQL-запросы и обновления таблиц", "Осуществляет соединение с удалённой базой данных", "Реализует пользовательский интерфейс для взаимодействия с данными"]', '["Определяет список сущностей (таблиц базы данных) и версию базы данных"]', 'ANDROID', 0, 0, 'Database — это абстрактный класс, который управляет базой данных, определяет список сущностей и версию базы данных, а также включает DAO.'),
                    ('За что отвечает Entity в библиотеке Room?', '', '["Определяет структуру таблицы в базе данных", "Хранит данные в виде объектов JSON", "Обрабатывает SQL-запросы к базе данных", "Определяет методы для взаимодействия с базой данных"]', '["Определяет структуру таблицы в базе данных"]', 'ANDROID', 0, 0, 'Entity — это классы, которые определяют структуру таблицы в базе данных. Каждый экземпляр `Entity` представляет строку в таблице.'),
                    ('За что отвечает DAO в библиотеке Room?', '', '["Определяет методы для доступа к базе данных", "Определяет структуру таблиц в базе данных", "Хранит данные в виде объектов JSON", "Управляет версией базы данных"]', '["Определяет методы для доступа к базе данных"]', 'ANDROID', 0, 0, 'DAO (Data Access Object) — это интерфейс, который определяет методы для доступа к базе данных. Room использует DAO для создания чистого API для вашего кода.'),
                    ('Какие модификаторы доступа в Java?', '', '["private", "public", "protected", "package-private (default)"]', '["private", "public", "protected", "package-private (default)"]', 'JAVA', 0, 0, 'Модификаторы доступа в Java определяют уровень доступа к членам класса. Они включают: `private`, `public`, `protected` и `package-private` (по умолчанию).'),
                    ('Какие модификаторы доступа в Kotlin?', '', '["private", "public", "protected", "internal"]', '["private", "public", "protected", "internal"]', 'KOTLIN', 0, 0, 'Модификаторы доступа в Kotlin включают: `private`, `public`, `protected` и `internal`. Каждый из них контролирует доступ к членам класса и видимость в зависимости от области видимости и уровня модификатора.'),
                    ('Какие существуют правила для методов equals и hashcode?', '', '["Переопределил equals - переопредели и hashcode", "Если хэшкоды разные, то объекты точно разные", "Если хэшкоды равны, то это не значит, что объекты равны", "Если объекты равны, то их хэшкоды тоже должны быть равны"]', '["Переопределил equals - переопредели и hashcode", "Если хэшкоды равны, то это не значит, что объекты равны", "Если объекты равны, то их хэшкоды тоже должны быть равны"]', 'JAVA', 0, 0, 'Правила для методов `equals` и `hashCode` таковы: 1) Если переопределил `equals`, то обязательно переопредели и `hashCode`. 2) Если объекты равны по `equals`, то их хэш-коды должны быть равны. 3) Если хэш-коды разные, объекты определенно разные. 4) Если хэш-коды равны, это не обязательно означает, что объекты равны, так как возможны коллизии хэш-кодов.'),
                    ('Как устроена память в Java?', '', '["Примитивные типы и ссылки хранятся в стэке", "Объекты хранятся в куче", "Примитивные типы хранятся в куче", "Ссылки хранятся в куче, а объекты в стэке"]', '["Примитивные типы и ссылки хранятся в стэке", "Объекты хранятся в куче"]', 'JAVA', 0, 0, 'В Java память для примитивных типов данных и ссылок на объекты хранится в стеке, в то время как сами объекты хранятся в куче. Стек используется для хранения данных метода, таких как локальные переменные и ссылки на объекты, а куча используется для динамического распределения памяти для объектов.'),
                    ('Какой объем памяти у стэка?', '', '["256 Кб", "512 Кб", "1 Мб", "2 Мб"]', '["1 Мб"]', 'JAVA', 0, 0, 'Объем памяти стэка в JVM может варьироваться в зависимости от конфигурации, но обычно устанавливается в диапазоне от 256 Кб до 1 Мб. Конкретное значение можно настроить с помощью параметра -Xss.'),
                    ('Какой объем памяти у кучи?', '', '["256 Мб", "1 Гб", "Ограничен размером оперативной памяти устройства", "2 Гб"]', '["Ограничен размером оперативной памяти устройства"]', 'JAVA', 0, 0, 'Объем памяти для кучи в JVM ограничен размером доступной оперативной памяти устройства, и его можно настроить с помощью параметров -Xmx и -Xms.'),
                    ('Если в приложении создано несколько потоков, то изменится ли от этого объем памяти стэка/кучи?', '', '["Для каждого потока будет создан свой собственный стэк размером 1 Мб, а куча будет использоваться общая и объем ее памяти не изменится", "Каждому потоку выделяется отдельный объем памяти в куче", "Объем памяти стэка и кучи будет увеличиваться пропорционально количеству потоков", "Куча будет автоматически увеличиваться для каждого потока"]', '["Для каждого потока будет создан свой собственный стэк размером 1 Мб, а куча будет использоваться общая и объем ее памяти не изменится"]', 'JAVA', 0, 0, 'При создании нескольких потоков в приложении для каждого потока выделяется отдельный стэк, размер которого обычно составляет 1 Мб, тогда как куча используется общая для всех потоков и ее объем остается постоянным, но может быть настроен.'),
                    ('Как сборщик мусора понимает, что объект можно уничтожить?', '', '["Если на объект нет ссылок из стэка", "Если объект не используется в методах", "Если объект создан внутри метода", "Если объект не имеет родительского класса"]', '["Если на объект нет ссылок из стэка"]', 'JAVA', 0, 0, 'Сборщик мусора в Java уничтожает объекты, на которые нет ссылок из стека. Это означает, что если на объект больше не ссылается ни одна переменная, он считается недостижимым и может быть удален для освобождения памяти.'),
                    ('Что такое final?', '', '["Ключевое слово, которое указывает, что от класса нельзя наследоваться", "Ключевое слово, которое указывает, что этот метод нельзя переопределить", "Ключевое слово, которое указывает, что переменная - константа", "Ключевое слово, которое указывает, что переменная имеет значение по умолчанию"]', '["Ключевое слово, которое указывает, что от класса нельзя наследоваться", "Ключевое слово, которое указывает, что этот метод нельзя переопределить", "Ключевое слово, которое указывает, что переменная - константа"]', 'JAVA', 0, 0, 'Ключевое слово `final` в Java используется для указания, что от класса нельзя наследоваться, что метод нельзя переопределить в подклассах и что переменная является константой, то есть ее значение не может быть изменено после инициализации.'),
                    ('Что такое finalize?', '', '["Метод, который вызывается при уничтожении объекта", "Метод, который вызывается при создании объекта", "Метод, который освобождает память, занятую объектом", "Метод, который вызывается для очистки ресурсов перед уничтожением объекта"]', '["Метод, который вызывается при уничтожении объекта", "Метод, который вызывается для очистки ресурсов перед уничтожением объекта"]', 'JAVA', 0, 0, 'Метод `finalize()` вызывается перед уничтожением объекта сборщиком мусора. Он предназначен для выполнения завершающих операций, таких как освобождение ресурсов, перед тем как объект будет удален из памяти.'),
                    ('Какие основные реализации List?', '', '["ArrayList", "LinkedList", "Vector", "Stack"]', '["ArrayList", "LinkedList"]', 'JAVA', 0, 0, 'Основными реализациями интерфейса `List` в Java являются `ArrayList` и `LinkedList`. `ArrayList` основан на массиве и обеспечивает быстрый доступ по индексу, а `LinkedList` основан на двусвязном списке и лучше подходит для частых операций вставки и удаления элементов.'),
                    ('Какие основные реализации Set?', '', '["HashSet", "TreeSet", "LinkedHashSet", "EnumSet"]', '["HashSet", "TreeSet", "LinkedHashSet"]', 'JAVA', 0, 0, 'Основными реализациями интерфейса `Set` в Java являются `HashSet`, `TreeSet` и `LinkedHashSet`. `HashSet` не гарантирует порядок элементов, `TreeSet` поддерживает отсортированный порядок, а `LinkedHashSet` сохраняет порядок вставки элементов.'),
                    ('Какие основные реализации Map?', '', '["HashMap", "TreeMap", "LinkedHashMap", "WeakHashMap"]', '["HashMap", "TreeMap", "LinkedHashMap"]', 'JAVA', 0, 0, 'Основными реализациями интерфейса `Map` в Java являются `HashMap`, `TreeMap` и `LinkedHashMap`. `HashMap` не гарантирует порядок элементов, `TreeMap` хранит элементы в отсортированном порядке, а `LinkedHashMap` сохраняет порядок вставки элементов.'),
                    ('Какой интерфейс реализует LinkedList?', '', '["List", "Queue", "Set", "Map"]', '["List", "Queue"]', 'JAVA', 0, 0, 'Класс `LinkedList` в Java реализует интерфейсы `List` и `Queue`. Он предоставляет методы для работы с элементами как в виде списка, так и в виде очереди.'),
                    ('От какого интерфейса наследуются List и Set?', '', '["Collection", "Iterable", "Map", "Queue"]', '["Collection"]', 'JAVA', 0, 0, 'Интерфейсы `List` и `Set` в Java наследуются от интерфейса `Collection`. Этот интерфейс представляет собой основное хранилище элементов в коллекциях и определяет базовые методы для работы с коллекциями.'),
                    ('Укажите правильную иерархию коллекций', '', '["Iterable - Collection - List, Set и интерфейс Map отдельно", "Iterable - Collection - List, Set, Map", "Collection - List, Set, Map", "Iterable - Collection - List - Set и Map отдельно"]', '["Iterable - Collection - List, Set и интерфейс Map отдельно"]', 'JAVA', 0, 0, 'Правильная иерархия коллекций в Java: `Iterable` -> `Collection` -> `List`, `Set` и интерфейс `Map` отдельно.'),
                    ('Выберите основные отличия коллекций Set и List', '', '["Set не позволяет хранить дубликаты", "Set не позволяет обращаться к элементам по их индексам", "В List элементы хранятся в порядке добавления, а в Set порядок может быть разным", "В Set быстрее работают методы remove и contains"]', '["Set не позволяет хранить дубликаты", "Set не позволяет обращаться к элементам по их индексам", "В List элементы хранятся в порядке добавления, а в Set порядок может быть разным"]', 'JAVA', 0, 0, 'Основные отличия коллекций `Set` и `List`: `Set` не позволяет хранить дубликаты, `Set` не позволяет обращаться к элементам по их индексам, в `List` элементы хранятся в порядке добавления, а в `Set` порядок может быть разным.'),
                    ('Что такое сериализация?', '', '["Процесс преобразования объектов в набор байтов", "Процесс преобразования байтов в объект", "Процесс сохранения состояния объекта на диск", "Процесс копирования объекта"]', '["Процесс преобразования объектов в набор байтов"]', 'JAVA', 0, 0, 'Сериализация — это процесс преобразования объектов в набор байтов, чтобы сохранить их состояние или передать через сети. Это позволяет сохранять объекты в файлы или передавать их между различными компонентами или системами.'),
                    ('Что делать, если нужно сериализовать объект, но одно из его полей несериализуемо?', '', '["Это поле можно пометить ключевым словом transient", "Это поле нужно удалить из класса", "Переопределить метод writeObject", "Использовать интерфейс Externalizable"]', '["Это поле можно пометить ключевым словом transient"]', 'JAVA', 0, 0, 'Если необходимо сериализовать объект, но одно из его полей несериализуемо, это поле можно пометить ключевым словом `transient`. Это указывает сериализатору игнорировать это поле при сериализации объекта.'),
                    ('Что будет, если из Java обратиться к internal полю Kotlin?', '', '["Для Java это поле будет иметь модификатор доступа public", "Для Java это поле будет недоступно", "Для Java это поле будет доступно только через reflection", "Для Java это поле будет иметь модификатор доступа protected"]', '["Для Java это поле будет недоступно"]', 'JAVA', 0, 0, 'Если из Java обратиться к полю с модификатором `internal` в Kotlin, это поле будет недоступно, так как `internal` доступен только в рамках того модуля, в котором он объявлен. В Java не существует понятия модификатора `internal`, и он не виден за пределами модуля.'),
                    ('Зачем в сервисах нужен метод onBind?', '', '["Если на какой-то сервис нужно подписаться и получать от него какие-то данные на экране, то для этого можно вызвать bindService, который вызывает onBind и возвращает реализацию интерфейса IBinder", "Метод onBind позволяет привязать сервис к компонентам, чтобы они могли взаимодействовать с ним через интерфейс IBinder", "Метод onBind позволяет сервису запустить свой процесс", "Метод onBind используется для завершения работы сервиса"]', '["Если на какой-то сервис нужно подписаться и получать от него какие-то данные на экране, то для этого можно вызвать bindService, который вызывает onBind и возвращает реализацию интерфейса IBinder", "Метод onBind позволяет привязать сервис к компонентам, чтобы они могли взаимодействовать с ним через интерфейс IBinder"]', 'ANDROID', 0, 0, 'Метод `onBind` в сервисах используется для привязки сервиса к компонентам, таким как активити или другие сервисы. Этот метод вызывается, когда `bindService` используется для подключения к сервису. Он возвращает объект `IBinder`, через который компонент может взаимодействовать с сервисом и получать данные.'),
                    ('Какой жизненный цикл у фрагмента?', '', '["onAttach - onCreate - onCreateView - onViewCreated - onStart - onResume - onPause - onStop - onDestroyView - onDestroy - onDetach", "onCreate - onCreateView - onViewCreated - onStart - onResume - onPause - onStop - onDestroy", "onAttach - onCreate - onViewCreated - onStart - onResume - onPause - onStop - onDestroy - onDetach", "onCreate - onCreateView - onStart - onResume - onPause - onStop - onDestroy"]', '["onAttach - onCreate - onCreateView - onViewCreated - onStart - onResume - onPause - onStop - onDestroyView - onDestroy - onDetach"]', 'ANDROID', 0, 0, 'Жизненный цикл фрагмента включает следующие методы: `onAttach`, `onCreate`, `onCreateView`, `onViewCreated`, `onStart`, `onResume`, `onPause`, `onStop`, `onDestroyView`, `onDestroy`, и `onDetach`. Эти методы обеспечивают управление состоянием фрагмента и его взаимодействием с активити.'),
                    ('Почему нельзя передавать параметры в конструктор фрагмента?', '', '["При пересоздании фрагмента вызывается его конструктор без параметров, если такого нет, то приложение упадет, а если есть, то переданные параметры не сохранятся", "Конструктор фрагмента может не быть вызван при пересоздании", "Параметры конструктора могут быть утеряны при пересоздании фрагмента", "Использование параметров конструктора делает фрагмент нестабильным при пересоздании"]', '["При пересоздании фрагмента вызывается его конструктор без параметров, если такого нет, то приложение упадет, а если есть, то переданные параметры не сохранятся"]', 'ANDROID', 0, 0, 'При пересоздании фрагмента вызывается его конструктор без параметров. Если такого конструктора нет, то приложение может упасть. Даже если конструктор с параметрами присутствует, переданные параметры могут не сохраняться, что делает этот подход ненадежным для передачи данных. Вместо этого рекомендуется использовать методы, такие как `setArguments()`, для передачи параметров.'),
                    ('Можно ли отправить свое broadcast - сообщение?', '', '["Можно, для этого нужно вызвать sendBroadcast", "Нет, это возможно только для системных сообщений", "Можно, но только через специфические API", "Нет, broadcast сообщения могут отправлять только системные компоненты"]', '["Можно, для этого нужно вызвать sendBroadcast"]', 'ANDROID', 0, 0, 'Да, можно отправить собственное broadcast-сообщение, используя метод sendBroadcast(). Этот метод позволяет отправлять сообщения, которые могут быть получены другими компонентами приложения или другими приложениями, если они зарегистрированы для получения такого сообщения.'),
                    ('Какие могут быть проблемы при использовании Thread для многопоточного кода?', '', '["Работать с View можно только из главного потока, поэтому для работы с View элементами придется пользоваться Handler-ом", "Жизненный цикл потока может отличаться от жизненного цикла экрана и это может спровоцировать утечки памяти", "Потоки могут иметь разные приоритеты, что может привести к некорректному выполнению задач", "Потоки могут конфликтовать друг с другом, вызывая проблемы синхронизации"]', '["Работать с View можно только из главного потока, поэтому для работы с View элементами придется пользоваться Handler-ом", "Жизненный цикл потока может отличаться от жизненного цикла экрана и это может спровоцировать утечки памяти"]', 'ANDROID', 0, 0, 'При использовании Threadдля многопоточного кода могут возникнуть следующие проблемы: во-первых, работу сViewможно выполнять только из главного потока, поэтому для взаимодействия с элементами пользовательского интерфейса нужно использоватьHandler. Во-вторых, жизненный цикл потока может не совпадать с жизненным циклом экрана, что может привести к утечкам памяти, если потоки не будут корректно завершены.'),
                    ('Что такое suspend-функция?', '', '["Функция, которая может приостановить свое выполнение до завершения какой-то долгой операции и затем возобновить его", "Функция, которая выполняется в параллельном потоке и не блокирует основной поток", "Функция, которая может быть вызвана только из другой suspend-функции", "Функция, которая автоматически обрабатывает исключения и возвращает результат выполнения"]', '["Функция, которая может приостановить свое выполнение до завершения какой-то долгой операции и затем возобновить его"]', 'KOTLIN', 0, 0, 'Suspend-функция — это функция, которая может приостановить свое выполнение до завершения какой-то долгой операции, а затем возобновить его. Она позволяет работать с асинхронными задачами и корутинами в Kotlin, обеспечивая удобный и эффективный способ обработки долгих операций без блокировки основного потока.'),
                    ('Почему нужно использовать suspend-функции?', '', '["Поток, на котором была вызвана suspend-функция, не будет заблокирован", "С использованием suspend-функций можно легко реализовать асинхронное программирование без явного управления потоками", "Suspend-функции упрощают код, так как они позволяют писать асинхронный код в линейном стиле", "Suspend-функции автоматически обрабатывают исключения, возникающие во время их выполнения"]', '["Поток, на котором была вызвана suspend-функция, не будет заблокирован"]', 'KOTLIN', 0, 0, 'Использование suspend-функций позволяет не блокировать поток, на котором они были вызваны, что делает асинхронное программирование более эффективным и удобным. Это упрощает реализацию долгих операций и обеспечивает более отзывчивый пользовательский интерфейс.'),
                    ('Каким образом обеспечивается возможность приостановки выполнения suspend-функции?', '', '["Под капотом suspend-функции используют программирование с коллбэками и state-машину", "Suspend-функции реализуют концепцию корутин и используют состояние для возобновления выполнения", "Используется механизм приостановки и возобновления выполнения на уровне байт-кода", "Используется специальный механизм планирования задач в корутинах"]', '["Под капотом suspend-функции используют программирование с коллбэками и state-машину"]', 'KOTLIN', 0, 0, 'Приостановка выполнения suspend-функции осуществляется за счет использования программирования с коллбэками и state-машины, что позволяет приостановить выполнение функции и возобновить его позже без блокировки потока.'),
                    ('Зачем нужны коллбэки?', '', '["Асинхронно обработать результат выполнения операции или выполнить дополнительный код после завершения работы функции", "Для синхронного выполнения кода в многопоточном окружении", "Для управления ресурсами в реальном времени", "Для упрощения работы с потоками данных"]', '["Асинхронно обработать результат выполнения операции или выполнить дополнительный код после завершения работы функции"]', 'BASE', 0, 0, 'Коллбэки нужны для асинхронной обработки результатов выполнения операций или выполнения дополнительного кода после завершения работы функции.'),
                    ('Что такое state-машина?', '', '["Модель, которая представляет систему в виде множества состояний и переходов, которые осуществляются в ответ на события или условия, между ними", "Структура данных, хранящая текущее состояние системы и ее историю", "Класс, который управляет изменением состояний в объектно-ориентированном программировании", "Метод, который определяет состояние объекта в момент выполнения"]', '["Модель, которая представляет систему в виде множества состояний и переходов, которые осуществляются в ответ на события или условия, между ними"]', 'BASE', 0, 0, 'State-машина — это модель, представляющая систему в виде множества состояний и переходов, которые осуществляются в ответ на события или условия.'),
                    ('Для чего нужна state-машина?', '', '["Для управления поведением системы и упрощения логики переходов", "Для хранения состояний объекта и их истории", "Для управления выполнением асинхронных задач", "Для определения структуры и порядка вызова функций"]', '["Для управления поведением системы и упрощения логики переходов"]', 'BASE', 0, 0, 'State-машина используется для управления поведением системы и упрощения логики переходов между различными состояниями.'),
                    ('Что такое коллбэк?', '', '["Механизм, позволяющий передать функцию или метод в качестве параметра другой функции или метода", "Способ асинхронной обработки данных", "Метод, который вызывается при завершении работы функции", "Функция, вызываемая для обработки ошибок"]', '["Механизм, позволяющий передать функцию или метод в качестве параметра другой функции или метода"]', 'BASE', 0, 0, 'Коллбэк — это механизм, позволяющий передать функцию или метод в качестве параметра другой функции или метода, чтобы этот переданный метод был вызван в определённый момент времени.'),
                    ('Если domain-слой не зависит от других слоев, то как он взаимодействует с data-слоем?', '', '["В domain-слое лежит интерфейс репозитория, с которым взаимодействуют usecases, а реализация этого репозитория лежит в data-слое", "Domain-слой напрямую использует классы из data-слоя", "Data-слой содержит интерфейсы, которые используют usecases из domain-слоя", "Domain-слой и data-слой имеют прямую зависимость друг от друга"]', '["В domain-слое лежит интерфейс репозитория, с которым взаимодействуют usecases, а реализация этого репозитория лежит в data-слое"]', 'BASE', 0, 0, 'Domain-слой в чистой архитектуре взаимодействует с data-слоем через интерфейсы. В domain-слое определяются интерфейсы репозиториев, которые используют usecases. Реализации этих репозиториев находятся в data-слое, что обеспечивает раздельное управление бизнес-логикой и доступом к данным.')
        """
                )

            }
        }


        fun getInstance(application: Application): QuestionDatabase {
            //Если не null, то сразу возвращаем значение
            INSTANCE?.let {
                return it
            }
            //double-check для нескольких потоков, что бы не меняли на разные значение
            synchronized(LOCK) {
                INSTANCE?.let {
                    return it
                }
                //если null, то
                val db = Room.databaseBuilder(
                    application,
                    QuestionDatabase::class.java,
                    DB_NAME
                )
                    //.fallbackToDestructiveMigration()
                    .addMigrations(MIGRATION_1_2, MIGRATION_2_3)
                    .createFromAsset("databases/new_question_database.db")
                    .build()
                Log.d("QuestionDatabase", "База данных успешно загружена.")
                //Log.d("QuestionDatabase", "База данных: ${db.}")
                INSTANCE = db
                return db
            }
        }

    }

}